/*Add synaptics new driver "Synaptics DSX I2C V2.0"*/
/*
 * Synaptics DSX touchscreen driver
 *
 * Copyright (C) 2012 Synaptics Incorporated
 *
 * Copyright (C) 2012 Alexandra Chin <alexandra.chin@tw.synaptics.com>
 * Copyright (C) 2012 Scott Lin <scott.lin@tw.synaptics.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 */
#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/slab.h>
#include <linux/i2c.h>
#include <linux/interrupt.h>
#include <linux/delay.h>
#include <linux/input.h>
#include <linux/ctype.h>
#include <linux/hrtimer.h>
#include "synaptics.h"
#include <../../huawei_touchscreen_chips.h>
#include <linux/gpio.h>
#include <linux/regulator/consumer.h>



#define WATCHDOG_HRTIMER
#define WATCHDOG_TIMEOUT_S 2
#define FORCE_TIMEOUT_100MS 10
#define MAX_I2C_MSG_LENS 0x3F
//#define STATUS_WORK_INTERVAL 20 /* ms */
/*Add synaptics capacitor test function */
#define MMITEST
/*
#define RAW_HEX
#define HUMAN_READABLE
*/
#define F54_MAX_CAP_TITLE_SIZE	50
#define IRQ_ON 1
#define IRQ_OFF 0
#define Interrupt_Enable_Addr  0x0052
#define IRQ_ENA_MASK_BIT 0x04
#define STATUS_IDLE 0
#define STATUS_BUSY 1

#define DATA_REPORT_INDEX_OFFSET 1
#define DATA_REPORT_DATA_OFFSET 3

#define SENSOR_RX_MAPPING_OFFSET 1
#define SENSOR_TX_MAPPING_OFFSET 2

#define COMMAND_GET_REPORT 1
#define COMMAND_FORCE_CAL 2
#define COMMAND_FORCE_UPDATE 4

#define CONTROL_42_SIZE 2
#define CONTROL_43_54_SIZE 13
#define CONTROL_55_56_SIZE 2
#define CONTROL_58_SIZE 1
#define CONTROL_59_SIZE 2
#define CONTROL_60_62_SIZE 3
#define CONTROL_63_SIZE 1
#define CONTROL_64_67_SIZE 4
#define CONTROL_68_73_SIZE 8
#define CONTROL_74_SIZE 2
#define CONTROL_76_SIZE 1
#define CONTROL_77_78_SIZE 2
#define CONTROL_79_83_SIZE 5
#define CONTROL_84_85_SIZE 2
#define CONTROL_86_SIZE 1
#define CONTROL_87_SIZE 1

#define HIGH_RESISTANCE_DATA_SIZE 6
#define FULL_RAW_CAP_MIN_MAX_DATA_SIZE 4
#define TREX_DATA_SIZE 7

#define NO_AUTO_CAL_MASK 0x01

#define concat(a, b) a##b

#define GROUP(_attrs) {\
	.attrs = _attrs,\
}

#define attrify(propname) (&dev_attr_##propname.attr)

#define show_prototype(propname)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf);\
\
static struct device_attribute dev_attr_##propname =\
		__ATTR(propname, S_IRUGO,\
		concat(synaptics_rmi4_f54, _##propname##_show),\
		NULL);

#define store_prototype(propname)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count);\
\
static struct device_attribute dev_attr_##propname =\
		__ATTR(propname, (S_IWUSR | S_IWGRP),\
		NULL,\
		concat(synaptics_rmi4_f54, _##propname##_store));

#define show_store_prototype(propname)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf);\
\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count);\
\
static struct device_attribute dev_attr_##propname =\
		__ATTR(propname, (S_IRUGO | S_IWUSR | S_IWGRP),\
		concat(synaptics_rmi4_f54, _##propname##_show),\
		concat(synaptics_rmi4_f54, _##propname##_store));

#define simple_show_func(rtype, propname, fmt)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf)\
{\
	return snprintf(buf, PAGE_SIZE, fmt, f54->rtype.propname);\
} \

#define simple_show_func_unsigned(rtype, propname)\
simple_show_func(rtype, propname, "%u\n")

#define show_func(rtype, rgrp, propname, fmt)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf)\
{\
	int retval;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	mutex_lock(&f54->rtype##_mutex);\
\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			f54->rtype.rgrp->data,\
			sizeof(f54->rtype.rgrp->data));\
	mutex_unlock(&f54->rtype##_mutex);\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
		return retval;\
	} \
\
	return snprintf(buf, PAGE_SIZE, fmt,\
			f54->rtype.rgrp->propname);\
} \

#define show_store_func(rtype, rgrp, propname, fmt)\
show_func(rtype, rgrp, propname, fmt)\
\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count)\
{\
	int retval;\
	unsigned long setting;\
	unsigned long o_setting;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	retval = sstrtoul(buf, 10, &setting);\
	if (retval)\
		return retval;\
\
	mutex_lock(&f54->rtype##_mutex);\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			f54->rtype.rgrp->data,\
			sizeof(f54->rtype.rgrp->data));\
	if (retval < 0) {\
		mutex_unlock(&f54->rtype##_mutex);\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
		return retval;\
	} \
\
	if (f54->rtype.rgrp->propname == setting) {\
		mutex_unlock(&f54->rtype##_mutex);\
		return count;\
	} \
\
	o_setting = f54->rtype.rgrp->propname;\
	f54->rtype.rgrp->propname = setting;\
\
	retval = f54->fn_ptr->write(rmi4_data,\
			f54->rtype.rgrp->address,\
			f54->rtype.rgrp->data,\
			sizeof(f54->rtype.rgrp->data));\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to write " #rtype\
				" " #rgrp "\n",\
				__func__);\
		f54->rtype.rgrp->propname = o_setting;\
		mutex_unlock(&f54->rtype##_mutex);\
		return retval;\
	} \
\
	mutex_unlock(&f54->rtype##_mutex);\
	return count;\
} \

#define show_store_func_unsigned(rtype, rgrp, propname)\
show_store_func(rtype, rgrp, propname, "%u\n")

#define show_replicated_func(rtype, rgrp, propname, fmt)\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_show)(\
		struct device *dev,\
		struct device_attribute *attr,\
		char *buf)\
{\
	int retval;\
	int size = 0;\
	unsigned char ii;\
	unsigned char length;\
	unsigned char *temp;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	mutex_lock(&f54->rtype##_mutex);\
\
	length = f54->rtype.rgrp->length;\
\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			(unsigned char *)f54->rtype.rgrp->data,\
			length);\
	mutex_unlock(&f54->rtype##_mutex);\
	if (retval < 0) {\
		dev_dbg(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
	} \
\
	temp = buf;\
\
	for (ii = 0; ii < length; ii++) {\
		retval = snprintf(temp, PAGE_SIZE - size, fmt " ",\
				f54->rtype.rgrp->data[ii].propname);\
		if (retval < 0) {\
			dev_err(&rmi4_data->i2c_client->dev,\
					"%s: Faild to write output\n",\
					__func__);\
			return retval;\
		} \
		size += retval;\
		temp += retval;\
	} \
\
	retval = snprintf(temp, PAGE_SIZE - size, "\n");\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Faild to write null terminator\n",\
				__func__);\
		return retval;\
	} \
\
	return size + retval;\
} \

#define show_replicated_func_unsigned(rtype, rgrp, propname)\
show_replicated_func(rtype, rgrp, propname, "%u")

#define show_store_replicated_func(rtype, rgrp, propname, fmt)\
show_replicated_func(rtype, rgrp, propname, fmt)\
\
static ssize_t concat(synaptics_rmi4_f54, _##propname##_store)(\
		struct device *dev,\
		struct device_attribute *attr,\
		const char *buf, size_t count)\
{\
	int retval;\
	unsigned int setting;\
	unsigned char ii;\
	unsigned char length;\
	const unsigned char *temp;\
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;\
\
	mutex_lock(&f54->rtype##_mutex);\
\
	length = f54->rtype.rgrp->length;\
\
	retval = f54->fn_ptr->read(rmi4_data,\
			f54->rtype.rgrp->address,\
			(unsigned char *)f54->rtype.rgrp->data,\
			length);\
	if (retval < 0) {\
		dev_dbg(&rmi4_data->i2c_client->dev,\
				"%s: Failed to read " #rtype\
				" " #rgrp "\n",\
				__func__);\
	} \
\
	temp = buf;\
\
	for (ii = 0; ii < length; ii++) {\
		if (sscanf(temp, fmt, &setting) == 1) {\
			f54->rtype.rgrp->data[ii].propname = setting;\
		} else {\
			retval = f54->fn_ptr->read(rmi4_data,\
					f54->rtype.rgrp->address,\
					(unsigned char *)f54->rtype.rgrp->data,\
					length);\
			mutex_unlock(&f54->rtype##_mutex);\
			return -EINVAL;\
		} \
\
		while (*temp != 0) {\
			temp++;\
			if (isspace(*(temp - 1)) && !isspace(*temp))\
				break;\
		} \
	} \
\
	retval = f54->fn_ptr->write(rmi4_data,\
			f54->rtype.rgrp->address,\
			(unsigned char *)f54->rtype.rgrp->data,\
			length);\
	mutex_unlock(&f54->rtype##_mutex);\
	if (retval < 0) {\
		dev_err(&rmi4_data->i2c_client->dev,\
				"%s: Failed to write " #rtype\
				" " #rgrp "\n",\
				__func__);\
		return retval;\
	} \
\
	return count;\
} \

#define show_store_replicated_func_unsigned(rtype, rgrp, propname)\
show_store_replicated_func(rtype, rgrp, propname, "%u")

enum f54_report_types {
	F54_8BIT_IMAGE = 1,
	F54_16BIT_IMAGE = 2,
	F54_RAW_16BIT_IMAGE = 3,
	F54_HIGH_RESISTANCE = 4,
	F54_TX_TO_TX_SHORT = 5,
	F54_RX_TO_RX1 = 7,
	F54_TRUE_BASELINE = 9,
	F54_FULL_RAW_CAP_MIN_MAX = 13,
	F54_RX_OPENS1 = 14,
	F54_TX_OPEN = 15,
	F54_TX_TO_GROUND = 16,
	F54_RX_TO_RX2 = 17,
	F54_RX_OPENS2 = 18,
	F54_FULL_RAW_CAP = 19,
	F54_FULL_RAW_CAP_RX_COUPLING_COMP = 20,
	F54_SENSOR_SPEED = 22,
	F54_ADC_RANGE = 23,
	F54_TREX_OPENS = 24,
	F54_TREX_TO_GND = 25,
	F54_TREX_SHORTS = 26,
	INVALID_REPORT_TYPE = -1,
};

/*Add synaptics capacitor test function */
#ifdef MMITEST
//#define CFG_F54_TXCOUNT	14
//#define CFG_F54_RXCOUNT	25
#define TOUCH_RX_DEFAULT 26
#define TOUCH_TX_DEFAULT 14
#define TP_TEST_FAILED_REASON_LEN 20

static unsigned char rx = TOUCH_RX_DEFAULT;
static unsigned char tx = TOUCH_TX_DEFAULT;

static bool sysfs_is_busy = false;
//modified cap test limit for G630-T00

extern struct ts_data g_ts_data;


static short FullRawMaxCap_oflim = 3600;//3854;
static short FullRawMaxCap_lensone= 3600;
static short FullRawMaxCap_oflim_g760s = 5000;
static short FullRawMaxCap_lensone_g760s = 4900;
static short FullRawMaxCap_GIS= 4000;
static short FullRawMaxCap_YASSY =4500;

static short FullRawMinCap_oflim = 1450; //0;
static short FullRawMinCap_lensone= 1450;
static short FullRawMinCap_oflim_g760s = 1700;
static short FullRawMinCap_lensone_g760s = 1700;
static short FullRawMinCap_GIS = 1200;
static short FullRawMinCap_YASSY =1200;

static short FullRawCapUpperLimit_oflim[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
3508,3543,3548,3526,3525,3523,3504,3493,3482,3467,3454,3441,3421,3119,3096,3110,3065,3082,3044,3063,3024,3042,3005,3026,2916,2808,
3396,3431,3416,3403,3387,3377,3364,3352,3340,3325,3314,3302,3279,3136,3110,3126,3085,3100,3066,3086,3048,3067,3031,3053,2944,2835,
3386,3419,3404,3389,3373,3359,3345,3330,3316,3299,3288,3272,3249,3137,3116,3129,3088,3101,3069,3092,3053,3073,3037,3059,2952,2842,
3383,3414,3400,3384,3365,3350,3335,3319,3305,3284,3273,3258,3236,3147,3127,3142,3101,3113,3080,3106,3066,3086,3052,3073,2966,2853,
3369,3401,3383,3368,3349,3334,3316,3304,3285,3266,3252,3237,3214,3152,3134,3146,3109,3119,3088,3111,3072,3092,3060,3081,2975,2844,
3359,3392,3372,3359,3339,3322,3303,3288,3272,3252,3239,3222,3196,3164,3145,3160,3122,3134,3101,3124,3089,3106,3075,3095,2990,2856,
3355,3389,3369,3355,3334,3318,3298,3283,3267,3243,3233,3214,3186,3183,3161,3178,3143,3154,3123,3145,3111,3129,3098,3117,3014,2875,
3348,3378,3361,3345,3325,3308,3290,3272,3254,3230,3219,3203,3174,3199,3180,3194,3159,3172,3138,3162,3130,3148,3116,3140,3033,2896,
3335,3367,3348,3331,3312,3297,3276,3258,3242,3215,3205,3191,3158,3213,3196,3209,3175,3191,3156,3182,3149,3169,3138,3161,3052,2912,
3335,3367,3347,3330,3308,3294,3273,3257,3239,3214,3204,3187,3157,3239,3223,3237,3203,3220,3188,3210,3178,3200,3171,3193,3085,2942,
3326,3357,3338,3322,3301,3287,3266,3249,3231,3208,3196,3180,3147,3259,3244,3258,3229,3244,3215,3234,3205,3227,3201,3222,3112,2990,
3323,3350,3334,3317,3296,3281,3262,3245,3225,3205,3193,3177,3143,3284,3269,3286,3258,3272,3245,3262,3239,3256,3232,3252,3142,3021,
3324,3355,3335,3316,3298,3283,3264,3247,3229,3207,3194,3179,3146,3321,3309,3327,3300,3317,3294,3309,3286,3307,3279,3298,3190,3075,
3318,3338,3320,3301,3280,3265,3244,3228,3206,3182,3168,3154,3116,3562,3530,3542,3492,3511,3490,3486,3466,3481,3448,3463,3351,3239
};
static short FullRawCapUpperLimit_lensone[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
3508,3543,3548,3526,3525,3523,3504,3493,3482,3467,3454,3441,3421,3119,3096,3110,3065,3082,3044,3063,3024,3042,3005,3026,2916,2808,
3396,3431,3416,3403,3387,3377,3364,3352,3340,3325,3314,3302,3279,3136,3110,3126,3085,3100,3066,3086,3048,3067,3031,3053,2944,2835,
3386,3419,3404,3389,3373,3359,3345,3330,3316,3299,3288,3272,3249,3137,3116,3129,3088,3101,3069,3092,3053,3073,3037,3059,2952,2842,
3383,3414,3400,3384,3365,3350,3335,3319,3305,3284,3273,3258,3236,3147,3127,3142,3101,3113,3080,3106,3066,3086,3052,3073,2966,2853,
3369,3401,3383,3368,3349,3334,3316,3304,3285,3266,3252,3237,3214,3152,3134,3146,3109,3119,3088,3111,3072,3092,3060,3081,2975,2844,
3359,3392,3372,3359,3339,3322,3303,3288,3272,3252,3239,3222,3196,3164,3145,3160,3122,3134,3101,3124,3089,3106,3075,3095,2990,2856,
3355,3389,3369,3355,3334,3318,3298,3283,3267,3243,3233,3214,3186,3183,3161,3178,3143,3154,3123,3145,3111,3129,3098,3117,3014,2875,
3348,3378,3361,3345,3325,3308,3290,3272,3254,3230,3219,3203,3174,3199,3180,3194,3159,3172,3138,3162,3130,3148,3116,3140,3033,2896,
3335,3367,3348,3331,3312,3297,3276,3258,3242,3215,3205,3191,3158,3213,3196,3209,3175,3191,3156,3182,3149,3169,3138,3161,3052,2912,
3335,3367,3347,3330,3308,3294,3273,3257,3239,3214,3204,3187,3157,3239,3223,3237,3203,3220,3188,3210,3178,3200,3171,3193,3085,2942,
3326,3357,3338,3322,3301,3287,3266,3249,3231,3208,3196,3180,3147,3259,3244,3258,3229,3244,3215,3234,3205,3227,3201,3222,3112,2990,
3323,3350,3334,3317,3296,3281,3262,3245,3225,3205,3193,3177,3143,3284,3269,3286,3258,3272,3245,3262,3239,3256,3232,3252,3142,3021,
3324,3355,3335,3316,3298,3283,3264,3247,3229,3207,3194,3179,3146,3321,3309,3327,3300,3317,3294,3309,3286,3307,3279,3298,3190,3075,
3318,3338,3320,3301,3280,3265,3244,3228,3206,3182,3168,3154,3116,3562,3530,3542,3492,3511,3490,3486,3466,3481,3448,3463,3351,3239
};
static short FullRawCapUpperLimit_oflim_g760s[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
3580, 3724, 3725, 3728, 3770, 3796, 3784, 3824, 3840, 3872, 3905, 3926, 3965, 4537, 4550, 4587, 4639, 4678, 4729, 4784, 4846, 4937, 4960, 4985, 4826,
3611, 3758, 3760, 3759, 3797, 3824, 3810, 3845, 3867, 3894, 3932, 3962, 4205, 4344, 4369, 4405, 4452, 4494, 4537, 4576, 4643, 4712, 4781, 4820, 4633,
3633, 3780, 3779, 3784, 3819, 3844, 3829, 3868, 3883, 3911, 3945, 3972, 4002, 4293, 4319, 4357, 4410, 4447, 4486, 4540, 4608, 4664, 4725, 4774, 4603,
3667, 3810, 3814, 3811, 3848, 3879, 3862, 3898, 3913, 3940, 3971, 3987, 4023, 4248, 4283, 4323, 4371, 4413, 4459, 4511, 4574, 4634, 4694, 4734, 4574,
3666, 3818, 3810, 3815, 3849, 3884, 3868, 3906, 3916, 3942, 3971, 4001, 4030, 4204, 4232, 4275, 4329, 4374, 4420, 4474, 4542, 4603, 4660, 4708, 4546,
3693, 3841, 3844, 3848, 3884, 3907, 3897, 3931, 3941, 3967, 4002, 4030, 4062, 4171, 4202, 4245, 4299, 4347, 4388, 4448, 4511, 4573, 4625, 4683, 4531,
3729, 3884, 3884, 3887, 3919, 3941, 3926, 3961, 3976, 4006, 4030, 4049, 4093, 4130, 4170, 4219, 4262, 4313, 4356, 4418, 4483, 4551, 4607, 4663, 4508,
3781, 3939, 3937, 3939, 3968, 3992, 3978, 4009, 4027, 4054, 4080, 4097, 4139, 4114, 4160, 4206, 4247, 4296, 4340, 4403, 4460, 4524, 4589, 4641, 4496,
3799, 3952, 3950, 3952, 3981, 4005, 4001, 4027, 4059, 4075, 4111, 4130, 4154, 4097, 4130, 4171, 4225, 4279, 4325, 4387, 4444, 4491, 4561, 4622, 4490,
3867, 4026, 4024, 4027, 4049, 4072, 4062, 4096, 4105, 4128, 4157, 4174, 4217, 4080, 4115, 4162, 4209, 4264, 4308, 4378, 4439, 4481, 4548, 4609, 4478,
3924, 4084, 4084, 4085, 4110, 4132, 4122, 4154, 4169, 4188, 4213, 4223, 4270, 4067, 4101, 4149, 4204, 4253, 4303, 4374, 4439, 4474, 4538, 4592, 4464,
3967, 4128, 4130, 4132, 4157, 4178, 4173, 4200, 4217, 4230, 4254, 4271, 4309, 4059, 4101, 4143, 4199, 4261, 4304, 4366, 4431, 4474, 4542, 4591, 4461,
4044, 4213, 4218, 4215, 4238, 4254, 4251, 4271, 4286, 4300, 4322, 4334, 4382, 4050, 4091, 4136, 4188, 4244, 4287, 4356, 4420, 4459, 4531, 4583, 4456,
4290, 4453, 4457, 4452, 4478, 4499, 4496, 4531, 4550, 4596, 4628, 4678, 4891, 4014, 4054, 4100, 4157, 4215, 4262, 4334, 4401, 4439, 4508, 4576, 4440
};
static short FullRawCapUpperLimit_lensone_760s[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
3525, 3705, 3693, 3727, 3706, 3731, 3759, 3746, 3789, 3820, 3854, 3880, 3872, 4422, 4466, 4504, 4537, 4579, 4612, 4664, 4709, 4772, 4782, 4823, 4699,
3562, 3723, 3711, 3737, 3708, 3731, 3760, 3767, 3794, 3845, 3875, 3898, 3900, 4204, 4258, 4293, 4329, 4365, 4407, 4462, 4509, 4553, 4598, 4639, 4512,
3568, 3727, 3703, 3724, 3698, 3719, 3746, 3760, 3790, 3845, 3879, 3903, 3906, 4170, 4196, 4230, 4279, 4309, 4358, 4413, 4466, 4511, 4553, 4600, 4460,
3567, 3732, 3706, 3723, 3708, 3729, 3749, 3757, 3792, 3835, 3868, 3890, 3903, 4101, 4152, 4183, 4223, 4257, 4304, 4355, 4405, 4453, 4491, 4538, 4439,
3602, 3767, 3715, 3750, 3733, 3759, 3784, 3786, 3814, 3854, 3888, 3910, 3915, 4070, 4117, 4158, 4188, 4235, 4277, 4334, 4377, 4435, 4479, 4522, 4420,
3632, 3802, 3744, 3790, 3771, 3809, 3825, 3816, 3850, 3881, 3900, 3910, 3919, 4035, 4093, 4143, 4179, 4225, 4257, 4306, 4344, 4387, 4434, 4481, 4379,
3673, 3837, 3777, 3819, 3802, 3822, 3831, 3845, 3887, 3894, 3907, 3946, 3949, 3996, 4059, 4119, 4150, 4193, 4225, 4275, 4304, 4349, 4392, 4448, 4338,
3724, 3849, 3809, 3842, 3832, 3850, 3871, 3879, 3918, 3929, 3953, 3983, 3987, 3965, 4006, 4070, 4123, 4184, 4222, 4265, 4305, 4344, 4397, 4451, 4353,
3760, 3885, 3837, 3874, 3855, 3883, 3881, 3910, 3955, 3968, 3993, 4022, 4019, 3944, 4006, 4067, 4111, 4165, 4205, 4247, 4287, 4342, 4409, 4457, 4369,
3799, 3915, 3870, 3892, 3890, 3901, 3919, 3949, 3976, 3991, 4015, 4039, 4046, 3916, 3972, 4036, 4076, 4128, 4166, 4222, 4264, 4323, 4401, 4452, 4358,
3833, 3970, 3922, 3954, 3949, 3972, 3983, 3994, 4043, 4052, 4076, 4104, 4104, 3923, 3975, 4026, 4058, 4109, 4163, 4200, 4244, 4308, 4386, 4436, 4340,
3898, 4011, 3984, 4010, 3994, 4014, 4024, 4054, 4083, 4098, 4119, 4140, 4156, 3914, 3962, 4023, 4049, 4096, 4132, 4192, 4240, 4278, 4340, 4407, 4304,
3959, 4079, 4074, 4091, 4083, 4104, 4098, 4140, 4144, 4153, 4170, 4192, 4218, 3903, 3970, 4011, 4045, 4101, 4140, 4195, 4245, 4286, 4339, 4396, 4296,
4195, 4351, 4318, 4340, 4332, 4345, 4387, 4408, 4438, 4470, 4490, 4524, 4660, 3894, 3957, 4013, 4058, 4106, 4153, 4212, 4274, 4338, 4410, 4456, 4348
};
static short FullRawCapUpperLimit_GIS[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
3072,3101,3099,3087,3085,3085,3065,3064,3051,3044,3036,3032,3114,2716,2718,2708,2696,2688,2700,2682,2682,2671,2668,2654,2650,2522,
3168,3193,3185,3168,3161,3158,3133,3129,3113,3103,3091,3085,3058,2915,2917,2906,2895,2888,2903,2885,2885,2875,2873,2858,2855,2756,
3161,3185,3175,3157,3149,3144,3118,3115,3095,3085,3072,3063,3026,2915,2915,2904,2892,2887,2900,2883,2883,2873,2871,2856,2858,2975,
3151,3177,3166,3147,3137,3132,3105,3100,3080,3068,3055,3048,3006,2921,2920,2910,2900,2893,2908,2890,2891,2880,2877,2864,2862,2804,
3136,3166,3154,3135,3126,3120,3093,3087,3066,3055,3041,3035,2990,2929,2927,2917,2909,2902,2917,2900,2900,2890,2887,2872,2870,2742,
3130,3159,3148,3129,3119,3113,3085,3079,3057,3045,3032,3024,2977,2941,2939,2929,2920,2914,2929,2911,2911,2901,2898,2885,2882,2765,
3124,3152,3139,3120,3109,3103,3074,3068,3046,3034,3020,3012,2963,2954,2950,2940,2930,2925,2940,2922,2922,2911,2908,2895,2897,2971,
3117,3144,3131,3111,3100,3095,3065,3059,3036,3025,3011,3003,2953,2973,2967,2957,2947,2941,2956,2938,2938,2927,2926,2910,2913,2974,
3112,3138,3126,3106,3094,3089,3061,3053,3031,3020,3006,2999,2947,2991,2983,2974,2966,2959,2975,2959,2959,2949,2947,2933,2933,2828,
3109,3136,3123,3103,3091,3085,3057,3050,3029,3018,3003,2995,2942,3013,3004,2996,2986,2980,2996,2979,2979,2970,2969,2956,2957,2852,
3106,3133,3120,3099,3088,3081,3052,3046,3024,3014,2998,2990,2938,3035,3023,3016,3007,3000,3016,3000,3000,2991,2990,2980,2982,2943,
3103,3131,3117,3097,3085,3079,3050,3045,3021,3011,2996,2989,2935,3056,3044,3036,3028,3021,3036,3020,3021,3013,3016,3005,3012,3198,
3099,3127,3115,3095,3085,3079,3052,3046,3024,3014,3000,2993,2939,3099,3078,3071,3064,3056,3073,3059,3060,3054,3057,3047,3049,3004,
2921,2939,2926,2905,2894,2886,2858,2850,2827,2817,2802,2794,2740,3510,3167,3138,3116,3101,3110,3091,3088,3080,3079,3069,3072,3169
};
static short FullRawCapUpperLimit_YASSY[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
3035,3317,3308,3308,3298,3288,3281,3272,3262,3256,3250,3239,3324,2841,2840,2829,2821,2814,2798,2801,2786,2791,2778,2771,2707,2544,
3307,3604,3587,3584,3571,3558,3546,3534,3521,3512,3504,3489,3480,3241,3246,3238,3231,3226,3213,3217,3202,3209,3197,3189,3120,2929,
3292,3591,3571,3564,3550,3536,3525,3510,3494,3484,3472,3457,3440,3244,3248,3239,3235,3230,3215,3220,3203,3210,3199,3192,3123,3001,
3286,3581,3560,3552,3535,3520,3509,3490,3475,3461,3451,3434,3414,3252,3255,3247,3246,3240,3225,3230,3214,3219,3211,3203,3132,2972,
3278,3570,3550,3540,3522,3504,3491,3474,3457,3446,3432,3416,3397,3268,3269,3261,3260,3253,3238,3246,3229,3233,3224,3216,3143,2951,
3269,3561,3537,3528,3505,3488,3474,3456,3440,3426,3413,3395,3376,3281,3283,3274,3273,3267,3258,3260,3244,3248,3241,3232,3156,2964,
3261,3551,3527,3517,3494,3476,3462,3444,3428,3414,3399,3383,3358,3297,3298,3291,3288,3283,3276,3275,3259,3264,3257,3248,3171,3049,
3251,3540,3515,3506,3487,3466,3449,3432,3415,3400,3388,3370,3345,3317,3320,3313,3310,3305,3299,3298,3282,3286,3281,3273,3197,3093,
3245,3532,3508,3501,3478,3455,3441,3423,3402,3387,3375,3357,3329,3338,3339,3334,3330,3329,3322,3322,3305,3311,3304,3298,3220,3034,
3246,3531,3508,3498,3475,3453,3441,3421,3399,3383,3371,3352,3324,3365,3367,3364,3359,3357,3351,3350,3335,3342,3333,3328,3251,3060,
3243,3528,3507,3492,3472,3448,3434,3414,3393,3378,3368,3348,3319,3397,3400,3396,3394,3392,3386,3385,3370,3377,3369,3363,3286,3134,
3237,3525,3500,3487,3467,3445,3427,3408,3387,3373,3361,3340,3311,3426,3428,3424,3423,3422,3416,3416,3403,3409,3401,3396,3321,3278,
3237,3522,3500,3489,3466,3444,3428,3408,3388,3374,3362,3343,3315,3474,3471,3470,3470,3471,3466,3465,3454,3460,3452,3448,3369,3194,
2907,3163,3138,3125,3099,3076,3057,3034,3014,2999,2985,2964,2936,3355,3242,3234,3230,3226,3219,3216,3202,3205,3198,3192,3120,3033
};


static short FullRawCapLowerLimit_oflim[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
1889,1908,1910,1899,1898,1897,1887,1881,1875,1867,1860,1853,1842,1680,1668,1675,1651,1660,1639,1649,1628,1638,1618,1630,1570,1512,
1829,1847,1840,1833,1824,1818,1812,1805,1798,1791,1784,1778,1766,1688,1675,1684,1661,1669,1651,1661,1642,1651,1632,1644,1585,1527,
1823,1841,1833,1825,1816,1808,1801,1793,1786,1776,1770,1762,1750,1689,1678,1685,1663,1670,1653,1665,1644,1654,1635,1647,1589,1530,
1821,1838,1830,1822,1812,1804,1795,1787,1779,1768,1762,1754,1742,1694,1684,1692,1670,1676,1658,1672,1651,1662,1643,1655,1597,1536,
1814,1831,1822,1814,1803,1795,1786,1779,1769,1758,1751,1743,1730,1697,1687,1694,1674,1679,1663,1675,1654,1665,1648,1659,1602,1531,
1809,1826,1816,1809,1798,1789,1778,1771,1762,1751,1744,1735,1721,1704,1693,1701,1681,1687,1670,1682,1663,1673,1656,1667,1610,1538,
1807,1825,1814,1807,1795,1787,1776,1767,1759,1746,1741,1730,1716,1714,1702,1711,1692,1698,1682,1694,1675,1685,1668,1679,1623,1548,
1803,1819,1810,1801,1790,1781,1772,1762,1752,1739,1733,1725,1709,1723,1712,1720,1701,1708,1689,1703,1685,1695,1678,1691,1633,1560,
1796,1813,1803,1794,1784,1775,1764,1754,1746,1731,1726,1718,1701,1730,1721,1728,1710,1718,1699,1714,1696,1706,1690,1702,1643,1568,
1796,1813,1802,1793,1782,1774,1762,1754,1744,1731,1725,1716,1700,1744,1735,1743,1725,1734,1716,1728,1711,1723,1707,1719,1661,1584,
1791,1807,1797,1788,1777,1769,1758,1749,1739,1727,1721,1712,1694,1755,1746,1754,1739,1747,1731,1741,1725,1737,1723,1735,1675,1610,
1789,1804,1795,1786,1775,1766,1756,1747,1736,1725,1719,1710,1692,1768,1760,1769,1754,1762,1747,1756,1744,1753,1740,1751,1692,1626,
1789,1806,1796,1785,1775,1767,1757,1748,1738,1727,1720,1712,1694,1788,1781,1791,1777,1786,1773,1782,1769,1780,1765,1776,1718,1655,
1786,1797,1787,1777,1766,1758,1747,1738,1726,1713,1706,1698,1678,1918,1901,1907,1880,1890,1879,1877,1866,1874,1856,1865,1804,1744
};
static short FullRawCapLowerLimit_lensone[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
1889,1908,1910,1899,1898,1897,1887,1881,1875,1867,1860,1853,1842,1680,1668,1675,1651,1660,1639,1649,1628,1638,1618,1630,1570,1512,
1829,1847,1840,1833,1824,1818,1812,1805,1798,1791,1784,1778,1766,1688,1675,1684,1661,1669,1651,1661,1642,1651,1632,1644,1585,1527,
1823,1841,1833,1825,1816,1808,1801,1793,1786,1776,1770,1762,1750,1689,1678,1685,1663,1670,1653,1665,1644,1654,1635,1647,1589,1530,
1821,1838,1830,1822,1812,1804,1795,1787,1779,1768,1762,1754,1742,1694,1684,1692,1670,1676,1658,1672,1651,1662,1643,1655,1597,1536,
1814,1831,1822,1814,1803,1795,1786,1779,1769,1758,1751,1743,1730,1697,1687,1694,1674,1679,1663,1675,1654,1665,1648,1659,1602,1531,
1809,1826,1816,1809,1798,1789,1778,1771,1762,1751,1744,1735,1721,1704,1693,1701,1681,1687,1670,1682,1663,1673,1656,1667,1610,1538,
1807,1825,1814,1807,1795,1787,1776,1767,1759,1746,1741,1730,1716,1714,1702,1711,1692,1698,1682,1694,1675,1685,1668,1679,1623,1548,
1803,1819,1810,1801,1790,1781,1772,1762,1752,1739,1733,1725,1709,1723,1712,1720,1701,1708,1689,1703,1685,1695,1678,1691,1633,1560,
1796,1813,1803,1794,1784,1775,1764,1754,1746,1731,1726,1718,1701,1730,1721,1728,1710,1718,1699,1714,1696,1706,1690,1702,1643,1568,
1796,1813,1802,1793,1782,1774,1762,1754,1744,1731,1725,1716,1700,1744,1735,1743,1725,1734,1716,1728,1711,1723,1707,1719,1661,1584,
1791,1807,1797,1788,1777,1769,1758,1749,1739,1727,1721,1712,1694,1755,1746,1754,1739,1747,1731,1741,1725,1737,1723,1735,1675,1610,
1789,1804,1795,1786,1775,1766,1756,1747,1736,1725,1719,1710,1692,1768,1760,1769,1754,1762,1747,1756,1744,1753,1740,1751,1692,1626,
1789,1806,1796,1785,1775,1767,1757,1748,1738,1727,1720,1712,1694,1788,1781,1791,1777,1786,1773,1782,1769,1780,1765,1776,1718,1655,
1786,1797,1787,1777,1766,1758,1747,1738,1726,1713,1706,1698,1678,1918,1901,1907,1880,1890,1879,1877,1866,1874,1856,1865,1804,1744
};
static short FullRawCapLowerLimit_oflim_g760s[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
1620, 1802, 1797, 1802, 1809, 1814, 1834, 1838, 1852, 1866, 1894, 1911, 1921, 2257, 2282, 2288 ,2323 ,2334 ,2372, 2385, 2420 ,2449, 2425, 2450, 2347,
1733, 1840, 1845, 1844, 1860, 1856, 1876, 1879, 1907, 1926, 1935, 1952, 1965, 2170, 2190, 2205, 2239, 2250, 2288, 2303, 2336, 2361, 2387, 2409, 2250,
1738, 1848, 1848, 1853, 1863, 1859, 1882, 1882, 1908, 1929, 1935, 1958, 1971, 2141, 2159, 2178, 2208, 2225, 2253, 2275, 2305, 2338, 2362, 2387, 2243,
1746, 1848, 1854, 1852, 1864, 1867, 1884, 1888, 1911, 1904, 1852, 1945, 1977, 2099, 2131, 2154, 2185, 2201, 2231, 2257, 2288, 2317, 2340, 2369, 2230,
1762, 1872, 1867, 1876, 1885, 1883, 1901, 1904, 1928, 1849, 1852, 1950, 1993, 2071, 2112, 2132, 2166, 2185, 2219, 2245, 2275, 2306, 2334, 2359, 2222,
1779, 1885, 1881, 1892, 1904, 1894, 1918, 1918, 1913, 1849, 1888, 1988, 2004, 2071, 2095, 2118, 2153, 2168, 2208, 2231, 2261, 2295, 2322, 2350, 2221,
1784, 1896, 1890, 1900, 1914, 1911, 1924, 1926, 1913, 1880, 1977, 1991, 2008, 2047, 2066, 2091, 2130, 2148, 2181, 2210, 2244, 2275, 2302, 2333, 2211,
1811, 1921, 1916, 1925, 1939, 1940, 1954, 1958, 1977, 1995, 2004, 2017, 2032, 2036, 2055, 2081, 2119, 2138, 2173, 2198, 2233, 2268, 2294, 2323, 2203,
1836, 1946, 1944, 1948, 1963, 1965, 1977, 1981, 2001, 2021, 2026, 2039, 2053, 2026, 2047, 2071, 2106, 2127, 2163, 2191, 2222, 2259, 2283, 2312, 2198,
1857, 1973, 1973, 1981, 1988, 1985, 2002, 2005, 2026, 2045, 2053, 2065, 2079, 2011, 2037, 2063, 2100, 2121, 2154, 2187, 2219, 2252, 2280, 2306, 2190,
1885, 2002, 2004, 2007, 2014, 2014, 2030, 2033, 2053, 2069, 2077, 2090, 2103, 1858, 2033, 2053, 2096, 2113, 2146, 2177, 2209, 2250, 2273, 2300, 2183,
1916, 2030, 2031, 2036, 2045, 2040, 2063, 2065, 2085, 2094, 2105, 2119, 2135, 1856, 2033, 2047, 2094, 2103, 2151, 2175, 2207, 2246, 2276, 2301, 2175,
1950, 2070, 2069, 2077, 2084, 2081, 2100, 2103, 2121, 2131, 2140, 2155, 2170, 1851, 2030, 2047, 2088, 2103, 2138, 2169, 2205, 2236, 2268, 2297, 2170,
2049, 2169, 2175, 2174, 2184, 2187, 2200, 2205, 2227, 2251, 2257, 2284, 2333, 1802, 2009, 2019, 2042, 2078, 2112, 2138, 2176, 2210, 2241, 2276, 2168
};
static short FullRawCapLowerLimit_lensone_g760s[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
1764, 1835, 1830, 1849, 1858, 1843, 1872, 1880, 1896, 1909, 1932, 1941, 1954, 2240, 2255, 2268, 2295, 2313, 2336, 2350, 2361, 2386, 2394, 2414, 2317,
1784, 1853, 1846, 1865, 1873, 1858, 1888, 1903, 1916, 1924, 1944, 1957, 1970, 2136, 2156, 2166, 2193, 2210, 2228, 2252, 2274, 2294, 2296, 2322, 2228,
1798, 1865, 1857, 1872, 1883, 1867, 1897, 1905, 1916, 1934, 1951, 1958, 1962, 2098, 2130, 2143, 2173, 2183, 2207, 2215, 2235, 2264, 2289, 2311, 2217,
1809, 1872, 1863, 1884, 1893, 1879, 1910, 1913, 1927, 1939, 1956, 1967, 1975, 2075, 2105, 2122, 2147, 2171, 2191, 2204, 2227, 2254, 2273, 2302, 2203,
1797, 1865, 1855, 1847, 1855, 1863, 1880, 1876, 1899, 1900, 1910, 1939, 1959, 2037, 2072, 2086, 2098, 2118, 2145, 2194, 2222, 2241, 2248, 2282, 2198,
1798, 1867, 1862, 1849, 1855, 1868, 1887, 1885, 1912, 1911, 1921, 1952, 1971, 2012, 2047, 2058, 2070, 2093, 2145, 2182, 2206, 2228, 2247, 2280, 2196,
1840, 1904, 1886, 1910, 1919, 1907, 1941, 1942, 1953, 1959, 1984, 1998, 2016, 2030, 2053, 2071, 2099, 2122, 2138, 2170, 2196, 2215, 2236, 2267, 2182,
1870, 1927, 1918, 1938, 1941, 1940, 1965, 1958, 1976, 1988, 2009, 2023, 2037, 2025, 2044, 2063, 2093, 2060, 2133, 2163, 2184, 2209, 2233, 2263, 2177,
1888, 1949, 1941, 1959, 1954, 1965, 1973, 1976, 1986, 2006, 2023, 2037, 2051, 2009, 2043, 2066, 2074, 2038, 2114, 2149, 2175, 2198, 2220, 2251, 2168,
1910, 1979, 1972, 1991, 1982, 1993, 1999, 2000, 2012, 2034, 2045, 2058, 2071, 2000, 2033, 2056, 2067, 2095, 2117, 2141, 2166, 2189, 2208, 2241, 2173,
1935, 2006, 1992, 2011, 2010, 2019, 2026, 2023, 2036, 2056, 2068, 2078, 2091, 1990, 2022, 2049, 2058, 2085, 2107, 2129, 2156, 2176, 2198, 2225, 2168,
1971, 2030, 2019, 2037, 2042, 2049, 2051, 2047, 2065, 2080, 2098, 2108, 2125, 1990, 2021, 2048, 2056, 2084, 2107, 2128, 2159, 2182, 2200, 2226, 2168,
2009, 2075, 2071, 2079, 2071, 2081, 2080, 2094, 2093, 2119, 2131, 2142, 2161, 1984, 2026, 2052, 2061, 2092, 2108, 2133, 2161, 2188, 2207, 2236, 2180,
2119, 2189, 2182, 2196, 2206, 2193, 2217, 2223, 2236, 2257, 2270, 2286, 2350, 1981, 2019, 2046, 2071, 2100, 2117, 2145, 2177, 2204, 2218, 2250, 2186
};
static short FullRawCapLowerLimit_GIS[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
1748,1767,1766,1758,1757,1757,1743,1743,1734,1729,1724,1721,1776,1511,1512,1505,1497,1492,1500,1488,1488,1464,1469,1468,1411,1381,
1812,1829,1823,1812,1807,1805,1788,1786,1775,1769,1761,1757,1739,1643,1645,1637,1630,1625,1636,1623,1623,1617,1615,1605,1568,1537,
1808,1823,1817,1805,1799,1796,1778,1776,1763,1756,1748,1742,1718,1643,1643,1636,1628,1624,1634,1622,1622,1616,1614,1604,1576,1616,
1801,1818,1811,1798,1792,1788,1770,1767,1753,1746,1737,1732,1704,1647,1647,1640,1633,1629,1639,1627,1627,1620,1618,1610,1594,1569,
1791,1810,1803,1790,1784,1780,1762,1758,1744,1737,1727,1723,1693,1653,1652,1645,1639,1634,1645,1633,1633,1627,1624,1615,1609,1528,
1786,1806,1799,1786,1779,1775,1756,1752,1738,1730,1721,1716,1684,1661,1659,1653,1647,1642,1653,1641,1641,1634,1632,1623,1622,1543,
1782,1801,1793,1780,1773,1768,1749,1746,1730,1723,1713,1708,1676,1670,1666,1660,1653,1650,1660,1648,1648,1641,1639,1630,1632,1670,
1778,1796,1788,1774,1767,1763,1744,1739,1724,1717,1708,1702,1669,1682,1678,1671,1665,1660,1671,1659,1659,1651,1651,1640,1642,1682,
1774,1792,1784,1771,1763,1759,1740,1735,1721,1713,1704,1699,1664,1694,1689,1683,1677,1673,1684,1673,1673,1666,1665,1655,1655,1586,
1773,1790,1782,1769,1761,1757,1738,1733,1719,1712,1702,1697,1662,1709,1703,1697,1691,1686,1698,1686,1686,1680,1680,1671,1672,1601,
1770,1788,1780,1766,1758,1754,1735,1731,1716,1709,1699,1694,1659,1723,1716,1711,1704,1700,1711,1700,1700,1694,1693,1686,1688,1662,
1769,1787,1778,1765,1757,1753,1733,1730,1714,1707,1697,1693,1657,1738,1729,1724,1718,1714,1724,1713,1714,1709,1711,1703,1708,1826,
1766,1785,1777,1763,1757,1753,1735,1731,1716,1709,1700,1696,1659,1766,1752,1747,1743,1738,1749,1739,1740,1736,1738,1731,1733,1703,
1647,1660,1650,1637,1629,1624,1605,1600,1585,1578,1568,1563,1527,2040,1811,1792,1777,1767,1774,1760,1759,1753,1752,1746,1682,1813
};
static short FullRawCapLowerLimit_YASSY[TOUCH_TX_DEFAULT*TOUCH_RX_DEFAULT] = {
1621,1790,1785,1785,1779,1773,1769,1763,1757,1753,1750,1744,1794,1504,1504,1498,1492,1488,1479,1481,1471,1474,1467,1463,1424,1326,
1784,1962,1952,1950,1943,1935,1928,1920,1913,1907,1903,1893,1888,1744,1747,1743,1739,1736,1728,1730,1721,1725,1718,1714,1672,1557,
1775,1954,1942,1939,1930,1922,1915,1906,1896,1890,1883,1874,1864,1746,1749,1744,1741,1738,1729,1732,1722,1726,1720,1715,1674,1601,
1772,1949,1936,1931,1921,1912,1906,1894,1885,1876,1870,1860,1848,1751,1753,1748,1748,1744,1735,1738,1728,1732,1726,1722,1679,1583,
1767,1942,1930,1924,1913,1903,1895,1885,1874,1868,1859,1849,1838,1761,1761,1756,1756,1752,1743,1748,1738,1740,1734,1730,1686,1571,
1761,1936,1922,1917,1903,1893,1884,1874,1864,1855,1848,1837,1826,1768,1770,1764,1764,1760,1755,1756,1746,1749,1744,1739,1694,1578,
1756,1930,1916,1910,1896,1886,1877,1867,1857,1848,1839,1830,1815,1778,1779,1774,1773,1770,1765,1765,1755,1758,1754,1749,1703,1630,
1750,1924,1909,1904,1892,1880,1870,1859,1849,1840,1833,1822,1807,1790,1792,1788,1786,1783,1779,1779,1769,1771,1769,1764,1718,1656,
1747,1919,1905,1900,1887,1873,1864,1854,1841,1832,1825,1814,1797,1803,1803,1800,1798,1797,1793,1793,1783,1787,1783,1779,1732,1621,
1748,1919,1905,1899,1885,1872,1865,1853,1839,1830,1823,1811,1794,1819,1820,1819,1816,1814,1811,1810,1801,1805,1800,1797,1751,1636,
1746,1917,1904,1895,1883,1869,1860,1849,1836,1827,1821,1809,1792,1838,1840,1837,1836,1835,1832,1831,1822,1826,1821,1818,1771,1680,
1742,1915,1900,1892,1880,1867,1856,1845,1832,1824,1817,1804,1787,1855,1857,1855,1854,1853,1850,1850,1842,1845,1840,1837,1793,1767,
1742,1914,1900,1893,1879,1867,1857,1845,1832,1824,1817,1806,1789,1885,1883,1882,1882,1882,1880,1879,1873,1876,1871,1869,1821,1716,
1544,1698,1683,1675,1659,1645,1634,1621,1609,1600,1591,1578,1561,1813,1745,1740,1738,1736,1732,1729,1721,1723,1719,1715,1672,1620
};

static short HighResistanceUpperLimit_oflim[3] = {500,450,-50};// {365,135,-121};
static short HighResistanceUpperLimit_lensone[3] = {500,450,-100};
static short HighResistanceUpperLimit_oflim_g760s[3] = {894, 573, 0x14};
static short HighResistanceUpperLimit_lensone_g760s[3] = {794, 600, 0x14};
static short HighResistanceUpperLimit_GIS[3] = {800,450,-50}; //{351,133,-163};
static short HighResistanceUpperLimit_YASSY[3] = {800,450,-50};//{669,300,-140};

static short HighResistanceLowerLimit_oflim[3] = {0,0,-600};//{227,28,-374};
static short HighResistanceLowerLimit_lensone[3] = {0,0,-600};
static short HighResistanceLowerLimit_oflim_g760s[3] = {0,0,0xfb50};
static short HighResistanceLowerLimit_lensone_g760s[3] = {0,0,0xfd21};
static short HighResistanceLowerLimit_GIS[3] = {0,0,-600}; //{275,56	,-238}
static short HighResistanceLowerLimit_YASSY[3] = {0,0,-600};//{249,208,-305}

static int RxDiagonalUpperLimit_oflim = 1100;
static int RxDiagonalUpperLimit_lensone = 1100;
static int RxDiagonalUpperLimit_oflim_g760s = 1150;
static int RxDiagonalUpperLimit_lensone_g760s = 1150;
static int RxDiagonalUpperLimit_GIS = 1100;
static int RxDiagonalUpperLimit_YASSY = 1100;

static int RxDiagonalLowerLimit_oflim = 900;
static int RxDiagonalLowerLimit_lensone = 900;
static int RxDiagonalLowerLimit_oflim_g760s = 850;
static int RxDiagonalLowerLimit_lensone_g760s = 850;
static int RxDiagonalLowerLimit_GIS = 900;
static int RxDiagonalLowerLimit_YASSY = 900;

static short FullRawMaxCap = 0;
static short FullRawMinCap = 0;

static short *FullRawCapUpperLimit = NULL;
static short *FullRawCapLowerLimit = NULL;

static short *HighResistanceUpperLimit = NULL;
static short *HighResistanceLowerLimit = NULL;

static int RxDiagonalUpperLimit = 0;
static int RxDiagonalLowerLimit = 0;


static int RxOthersUpperLimit = 250;
static char TxTxReportLimit = 0;
enum mmi_results {
	TEST_FAILED,
	TEST_PASS,
};
static char tp_test_failed_reason[TP_TEST_FAILED_REASON_LEN] = {"-software_reason"};
static char *g_mmi_buf_f54test_result = NULL;
static char *g_mmi_highresistance_report = NULL;
static char *g_mmi_maxmincapacitance_report = NULL;
static char *g_mmi_RxtoRxshort_report = NULL;
static char *g_mmi_buf_f54raw_data = NULL;
static char *g_buf_debug_data = NULL;
extern struct ts_data g_ts_data;
static char g_synaptics_trigger_log_flag = 0;
#endif

static int synaptics_rmi4_f54_attention(void);

struct f54_query {
	union {
		struct {
			/* query 0 */
			unsigned char num_of_rx_electrodes;

			/* query 1 */
			unsigned char num_of_tx_electrodes;

			/* query 2 */
			unsigned char f54_query2_b0__1:2;
			unsigned char has_baseline:1;
			unsigned char has_image8:1;
			unsigned char f54_query2_b4__5:2;
			unsigned char has_image16:1;
			unsigned char f54_query2_b7:1;

			/* queries 3.0 and 3.1 */
			unsigned short clock_rate;

			/* query 4 */
			unsigned char touch_controller_family;

			/* query 5 */
			unsigned char has_pixel_touch_threshold_adjustment:1;
			unsigned char f54_query5_b1__7:7;

			/* query 6 */
			unsigned char has_sensor_assignment:1;
			unsigned char has_interference_metric:1;
			unsigned char has_sense_frequency_control:1;
			unsigned char has_firmware_noise_mitigation:1;
			unsigned char has_ctrl11:1;
			unsigned char has_two_byte_report_rate:1;
			unsigned char has_one_byte_report_rate:1;
			unsigned char has_relaxation_control:1;

			/* query 7 */
			unsigned char curve_compensation_mode:2;
			unsigned char f54_query7_b2__7:6;

			/* query 8 */
			unsigned char f54_query8_b0:1;
			unsigned char has_iir_filter:1;
			unsigned char has_cmn_removal:1;
			unsigned char has_cmn_maximum:1;
			unsigned char has_touch_hysteresis:1;
			unsigned char has_edge_compensation:1;
			unsigned char has_per_frequency_noise_control:1;
			unsigned char has_enhanced_stretch:1;

			/* query 9 */
			unsigned char has_force_fast_relaxation:1;
			unsigned char has_multi_metric_state_machine:1;
			unsigned char has_signal_clarity:1;
			unsigned char has_variance_metric:1;
			unsigned char has_0d_relaxation_control:1;
			unsigned char has_0d_acquisition_control:1;
			unsigned char has_status:1;
			unsigned char has_slew_metric:1;

			/* query 10 */
			unsigned char has_h_blank:1;
			unsigned char has_v_blank:1;
			unsigned char has_long_h_blank:1;
			unsigned char has_startup_fast_relaxation:1;
			unsigned char has_esd_control:1;
			unsigned char has_noise_mitigation2:1;
			unsigned char has_noise_state:1;
			unsigned char has_energy_ratio_relaxation:1;

			/* query 11 */
			unsigned char has_excessive_noise_reporting:1;
			unsigned char has_slew_option:1;
			unsigned char has_two_overhead_bursts:1;
			unsigned char has_query13:1;
			unsigned char has_one_overhead_burst:1;
			unsigned char f54_query11_b5:1;
			unsigned char has_ctrl88:1;
			unsigned char has_query15:1;

			/* query 12 */
			unsigned char number_of_sensing_frequencies:4;
			unsigned char f54_query12_b4__7:4;

			/* query 13 */
			unsigned char has_ctrl86:1;
			unsigned char has_ctrl87:1;
			unsigned char has_ctrl87_sub0:1;
			unsigned char has_ctrl87_sub1:1;
			unsigned char has_ctrl87_sub2:1;
			unsigned char has_cidim:1;
			unsigned char has_noise_mitigation_enhancement:1;
			unsigned char has_rail_im:1;
		} __packed;
		unsigned char data[15];
	};
};

struct f54_control_0 {
	union {
		struct {
			unsigned char no_relax:1;
			unsigned char no_scan:1;
			unsigned char force_fast_relaxation:1;
			unsigned char startup_fast_relaxation:1;
			unsigned char gesture_cancels_sfr:1;
			unsigned char enable_energy_ratio_relaxation:1;
			unsigned char excessive_noise_attn_enable:1;
			unsigned char f54_control0_b7:1;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_1 {
	union {
		struct {
			unsigned char bursts_per_cluster:4;
			unsigned char f54_ctrl1_b4__7:4;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_2 {
	union {
		struct {
			unsigned short saturation_cap;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_3 {
	union {
		struct {
			unsigned char pixel_touch_threshold;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_4__6 {
	union {
		struct {
			/* control 4 */
			unsigned char rx_feedback_cap:2;
			unsigned char bias_current:2;
			unsigned char f54_ctrl4_b4__7:4;

			/* control 5 */
			unsigned char low_ref_cap:2;
			unsigned char low_ref_feedback_cap:2;
			unsigned char low_ref_polarity:1;
			unsigned char f54_ctrl5_b5__7:3;

			/* control 6 */
			unsigned char high_ref_cap:2;
			unsigned char high_ref_feedback_cap:2;
			unsigned char high_ref_polarity:1;
			unsigned char f54_ctrl6_b5__7:3;
		} __packed;
		struct {
			unsigned char data[3];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_7 {
	union {
		struct {
			unsigned char cbc_cap:3;
			unsigned char cbc_polarity:1;
			unsigned char cbc_tx_carrier_selection:1;
			unsigned char f54_ctrl7_b5__7:3;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_8__9 {
	union {
		struct {
			/* control 8 */
			unsigned short integration_duration:10;
			unsigned short f54_ctrl8_b10__15:6;

			/* control 9 */
			unsigned char reset_duration;
		} __packed;
		struct {
			unsigned char data[3];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_10 {
	union {
		struct {
			unsigned char noise_sensing_bursts_per_image:4;
			unsigned char f54_ctrl10_b4__7:4;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_11 {
	union {
		struct {
			unsigned short f54_ctrl11;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_12__13 {
	union {
		struct {
			/* control 12 */
			unsigned char slow_relaxation_rate;

			/* control 13 */
			unsigned char fast_relaxation_rate;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_14 {
	union {
		struct {
			unsigned char rxs_on_xaxis:1;
			unsigned char curve_comp_on_txs:1;
			unsigned char f54_ctrl14_b2__7:6;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_15n {
	unsigned char sensor_rx_assignment;
};

struct f54_control_15 {
	struct f54_control_15n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_16n {
	unsigned char sensor_tx_assignment;
};

struct f54_control_16 {
	struct f54_control_16n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_17n {
	unsigned char burst_count_b8__10:3;
	unsigned char disable:1;
	unsigned char f54_ctrl17_b4:1;
	unsigned char filter_bandwidth:3;
};

struct f54_control_17 {
	struct f54_control_17n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_18n {
	unsigned char burst_count_b0__7;
};

struct f54_control_18 {
	struct f54_control_18n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_19n {
	unsigned char stretch_duration;
};

struct f54_control_19 {
	struct f54_control_19n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_20 {
	union {
		struct {
			unsigned char disable_noise_mitigation:1;
			unsigned char f54_ctrl20_b1__7:7;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_21 {
	union {
		struct {
			unsigned short freq_shift_noise_threshold;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_22__26 {
	union {
		struct {
			/* control 22 */
			unsigned char f54_ctrl22;

			/* control 23 */
			unsigned short medium_noise_threshold;

			/* control 24 */
			unsigned short high_noise_threshold;

			/* control 25 */
			unsigned char noise_density;

			/* control 26 */
			unsigned char frame_count;
		} __packed;
		struct {
			unsigned char data[7];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_27 {
	union {
		struct {
			unsigned char iir_filter_coef;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_28 {
	union {
		struct {
			unsigned short quiet_threshold;
		} __packed;
		struct {
			unsigned char data[2];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_29 {
	union {
		struct {
			/* control 29 */
			unsigned char f54_ctrl29_b0__6:7;
			unsigned char cmn_filter_disable:1;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_30 {
	union {
		struct {
			unsigned char cmn_filter_max;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_31 {
	union {
		struct {
			unsigned char touch_hysteresis;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_32__35 {
	union {
		struct {
			/* control 32 */
			unsigned short rx_low_edge_comp;

			/* control 33 */
			unsigned short rx_high_edge_comp;

			/* control 34 */
			unsigned short tx_low_edge_comp;

			/* control 35 */
			unsigned short tx_high_edge_comp;
		} __packed;
		struct {
			unsigned char data[8];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_36n {
	unsigned char axis1_comp;
};

struct f54_control_36 {
	struct f54_control_36n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_37n {
	unsigned char axis2_comp;
};

struct f54_control_37 {
	struct f54_control_37n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_38n {
	unsigned char noise_control_1;
};

struct f54_control_38 {
	struct f54_control_38n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_39n {
	unsigned char noise_control_2;
};

struct f54_control_39 {
	struct f54_control_39n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_40n {
	unsigned char noise_control_3;
};

struct f54_control_40 {
	struct f54_control_40n *data;
	unsigned short address;
	unsigned char length;
};

struct f54_control_41 {
	union {
		struct {
			unsigned char no_signal_clarity:1;
			unsigned char f54_ctrl41_b1__7:7;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_57 {
	union {
		struct {
			unsigned char cbc_cap_0d:3;
			unsigned char cbc_polarity_0d:1;
			unsigned char cbc_tx_carrier_selection_0d:1;
			unsigned char f54_ctrl57_b5__7:3;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control_88 {
	union {
		struct {
			unsigned char tx_low_reference_polarity:1;
			unsigned char tx_high_reference_polarity:1;
			unsigned char abs_low_reference_polarity:1;
			unsigned char abs_polarity:1;
			unsigned char cbc_polarity:1;
			unsigned char cbc_tx_carrier_selection:1;
			unsigned char charge_pump_enable:1;
			unsigned char cbc_abs_auto_servo:1;
		} __packed;
		struct {
			unsigned char data[1];
			unsigned short address;
		} __packed;
	};
};

struct f54_control {
	struct f54_control_0 *reg_0;
	struct f54_control_1 *reg_1;
	struct f54_control_2 *reg_2;
	struct f54_control_3 *reg_3;
	struct f54_control_4__6 *reg_4__6;
	struct f54_control_7 *reg_7;
	struct f54_control_8__9 *reg_8__9;
	struct f54_control_10 *reg_10;
	struct f54_control_11 *reg_11;
	struct f54_control_12__13 *reg_12__13;
	struct f54_control_14 *reg_14;
	struct f54_control_15 *reg_15;
	struct f54_control_16 *reg_16;
	struct f54_control_17 *reg_17;
	struct f54_control_18 *reg_18;
	struct f54_control_19 *reg_19;
	struct f54_control_20 *reg_20;
	struct f54_control_21 *reg_21;
	struct f54_control_22__26 *reg_22__26;
	struct f54_control_27 *reg_27;
	struct f54_control_28 *reg_28;
	struct f54_control_29 *reg_29;
	struct f54_control_30 *reg_30;
	struct f54_control_31 *reg_31;
	struct f54_control_32__35 *reg_32__35;
	struct f54_control_36 *reg_36;
	struct f54_control_37 *reg_37;
	struct f54_control_38 *reg_38;
	struct f54_control_39 *reg_39;
	struct f54_control_40 *reg_40;
	struct f54_control_41 *reg_41;
	struct f54_control_57 *reg_57;
	struct f54_control_88 *reg_88;
};

struct synaptics_rmi4_f54_handle {
	bool no_auto_cal;
	unsigned char status;
	unsigned char intr_mask;
	unsigned char intr_reg_num;
	unsigned char rx_assigned;
	unsigned char tx_assigned;
	unsigned char *report_data;
	unsigned short query_base_addr;
	unsigned short control_base_addr;
	unsigned short data_base_addr;
	unsigned short command_base_addr;
	unsigned short fifoindex;
	unsigned int report_size;
	unsigned int data_buffer_size;
	enum f54_report_types report_type;
	struct mutex status_mutex;
	struct mutex data_mutex;
	struct mutex control_mutex;
	struct f54_query query;
	struct f54_control control;
	struct kobject *attr_dir;
	struct hrtimer watchdog;
	struct work_struct timeout_work;
	struct delayed_work status_work;
	struct workqueue_struct *status_workqueue;
	struct synaptics_rmi4_exp_fn_ptr *fn_ptr;
	struct synaptics_rmi4_data *rmi4_data;
};

struct f55_query {
	union {
		struct {
			/* query 0 */
			unsigned char num_of_rx_electrodes;

			/* query 1 */
			unsigned char num_of_tx_electrodes;

			/* query 2 */
			unsigned char has_sensor_assignment:1;
			unsigned char has_edge_compensation:1;
			unsigned char curve_compensation_mode:2;
			unsigned char has_ctrl6:1;
			unsigned char has_alternate_transmitter_assignment:1;
			unsigned char has_single_layer_multi_touch:1;
			unsigned char has_query5:1;
		} __packed;
		unsigned char data[3];
	};
};

struct synaptics_rmi4_f55_handle {
	unsigned char *rx_assignment;
	unsigned char *tx_assignment;
	unsigned short query_base_addr;
	unsigned short control_base_addr;
	unsigned short data_base_addr;
	unsigned short command_base_addr;
	struct f55_query query;
};

show_prototype(tp_status)
show_prototype(report_size)
show_store_prototype(no_auto_cal)
show_store_prototype(report_type)
show_store_prototype(fifoindex)
store_prototype(do_preparation)
store_prototype(get_report)
store_prototype(force_cal)
store_prototype(resume_touch)
show_prototype(num_of_mapped_rx)
show_prototype(num_of_mapped_tx)
show_prototype(num_of_rx_electrodes)
show_prototype(num_of_tx_electrodes)
show_prototype(has_image16)
show_prototype(has_image8)
show_prototype(has_baseline)
show_prototype(clock_rate)
show_prototype(touch_controller_family)
show_prototype(has_pixel_touch_threshold_adjustment)
show_prototype(has_sensor_assignment)
show_prototype(has_interference_metric)
show_prototype(has_sense_frequency_control)
show_prototype(has_firmware_noise_mitigation)
show_prototype(has_two_byte_report_rate)
show_prototype(has_one_byte_report_rate)
show_prototype(has_relaxation_control)
show_prototype(curve_compensation_mode)
show_prototype(has_iir_filter)
show_prototype(has_cmn_removal)
show_prototype(has_cmn_maximum)
show_prototype(has_touch_hysteresis)
show_prototype(has_edge_compensation)
show_prototype(has_per_frequency_noise_control)
show_prototype(has_signal_clarity)
show_prototype(number_of_sensing_frequencies)

show_store_prototype(no_relax)
show_store_prototype(no_scan)
show_store_prototype(bursts_per_cluster)
show_store_prototype(saturation_cap)
show_store_prototype(pixel_touch_threshold)
show_store_prototype(rx_feedback_cap)
show_store_prototype(low_ref_cap)
show_store_prototype(low_ref_feedback_cap)
show_store_prototype(low_ref_polarity)
show_store_prototype(high_ref_cap)
show_store_prototype(high_ref_feedback_cap)
show_store_prototype(high_ref_polarity)
show_store_prototype(cbc_cap)
show_store_prototype(cbc_polarity)
show_store_prototype(cbc_tx_carrier_selection)
show_store_prototype(integration_duration)
show_store_prototype(reset_duration)
show_store_prototype(noise_sensing_bursts_per_image)
show_store_prototype(slow_relaxation_rate)
show_store_prototype(fast_relaxation_rate)
show_store_prototype(rxs_on_xaxis)
show_store_prototype(curve_comp_on_txs)
show_prototype(sensor_rx_assignment)
show_prototype(sensor_tx_assignment)
show_prototype(burst_count)
show_prototype(disable)
show_prototype(filter_bandwidth)
show_prototype(stretch_duration)
show_store_prototype(disable_noise_mitigation)
show_store_prototype(freq_shift_noise_threshold)
show_store_prototype(medium_noise_threshold)
show_store_prototype(high_noise_threshold)
show_store_prototype(noise_density)
show_store_prototype(frame_count)
show_store_prototype(iir_filter_coef)
show_store_prototype(quiet_threshold)
show_store_prototype(cmn_filter_disable)
show_store_prototype(cmn_filter_max)
show_store_prototype(touch_hysteresis)
show_store_prototype(rx_low_edge_comp)
show_store_prototype(rx_high_edge_comp)
show_store_prototype(tx_low_edge_comp)
show_store_prototype(tx_high_edge_comp)
show_store_prototype(axis1_comp)
show_store_prototype(axis2_comp)
show_prototype(noise_control_1)
show_prototype(noise_control_2)
show_prototype(noise_control_3)
show_store_prototype(no_signal_clarity)
show_store_prototype(cbc_cap_0d)
show_store_prototype(cbc_polarity_0d)
show_store_prototype(cbc_tx_carrier_selection_0d)
/*Add synaptics capacitor test function */
#ifdef MMITEST
show_prototype(mmi_test)
show_prototype(mmi_test_result)
#endif

static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
		struct kobject *kobj, struct bin_attribute *attributes,
		char *buf, loff_t pos, size_t count);

static struct attribute *attrs[] = {
	attrify(tp_status),
	attrify(report_size),
	attrify(no_auto_cal),
	attrify(report_type),
	attrify(fifoindex),
	attrify(do_preparation),
	attrify(get_report),
	attrify(force_cal),
	attrify(resume_touch),
	attrify(num_of_mapped_rx),
	attrify(num_of_mapped_tx),
	attrify(num_of_rx_electrodes),
	attrify(num_of_tx_electrodes),
	attrify(has_image16),
	attrify(has_image8),
	attrify(has_baseline),
	attrify(clock_rate),
	attrify(touch_controller_family),
	attrify(has_pixel_touch_threshold_adjustment),
	attrify(has_sensor_assignment),
	attrify(has_interference_metric),
	attrify(has_sense_frequency_control),
	attrify(has_firmware_noise_mitigation),
	attrify(has_two_byte_report_rate),
	attrify(has_one_byte_report_rate),
	attrify(has_relaxation_control),
	attrify(curve_compensation_mode),
	attrify(has_iir_filter),
	attrify(has_cmn_removal),
	attrify(has_cmn_maximum),
	attrify(has_touch_hysteresis),
	attrify(has_edge_compensation),
	attrify(has_per_frequency_noise_control),
	attrify(has_signal_clarity),
	attrify(number_of_sensing_frequencies),
#ifdef MMITEST
	attrify(mmi_test),
	attrify(mmi_test_result),
#endif
	NULL,
};

static struct attribute_group attr_group = GROUP(attrs);

static struct attribute *attrs_reg_0[] = {
	attrify(no_relax),
	attrify(no_scan),
	NULL,
};

static struct attribute *attrs_reg_1[] = {
	attrify(bursts_per_cluster),
	NULL,
};

static struct attribute *attrs_reg_2[] = {
	attrify(saturation_cap),
	NULL,
};

static struct attribute *attrs_reg_3[] = {
	attrify(pixel_touch_threshold),
	NULL,
};

static struct attribute *attrs_reg_4__6[] = {
	attrify(rx_feedback_cap),
	attrify(low_ref_cap),
	attrify(low_ref_feedback_cap),
	attrify(low_ref_polarity),
	attrify(high_ref_cap),
	attrify(high_ref_feedback_cap),
	attrify(high_ref_polarity),
	NULL,
};

static struct attribute *attrs_reg_7[] = {
	attrify(cbc_cap),
	attrify(cbc_polarity),
	attrify(cbc_tx_carrier_selection),
	NULL,
};

static struct attribute *attrs_reg_8__9[] = {
	attrify(integration_duration),
	attrify(reset_duration),
	NULL,
};

static struct attribute *attrs_reg_10[] = {
	attrify(noise_sensing_bursts_per_image),
	NULL,
};

static struct attribute *attrs_reg_11[] = {
	NULL,
};

static struct attribute *attrs_reg_12__13[] = {
	attrify(slow_relaxation_rate),
	attrify(fast_relaxation_rate),
	NULL,
};

static struct attribute *attrs_reg_14__16[] = {
	attrify(rxs_on_xaxis),
	attrify(curve_comp_on_txs),
	attrify(sensor_rx_assignment),
	attrify(sensor_tx_assignment),
	NULL,
};

static struct attribute *attrs_reg_17__19[] = {
	attrify(burst_count),
	attrify(disable),
	attrify(filter_bandwidth),
	attrify(stretch_duration),
	NULL,
};

static struct attribute *attrs_reg_20[] = {
	attrify(disable_noise_mitigation),
	NULL,
};

static struct attribute *attrs_reg_21[] = {
	attrify(freq_shift_noise_threshold),
	NULL,
};

static struct attribute *attrs_reg_22__26[] = {
	attrify(medium_noise_threshold),
	attrify(high_noise_threshold),
	attrify(noise_density),
	attrify(frame_count),
	NULL,
};

static struct attribute *attrs_reg_27[] = {
	attrify(iir_filter_coef),
	NULL,
};

static struct attribute *attrs_reg_28[] = {
	attrify(quiet_threshold),
	NULL,
};

static struct attribute *attrs_reg_29[] = {
	attrify(cmn_filter_disable),
	NULL,
};

static struct attribute *attrs_reg_30[] = {
	attrify(cmn_filter_max),
	NULL,
};

static struct attribute *attrs_reg_31[] = {
	attrify(touch_hysteresis),
	NULL,
};

static struct attribute *attrs_reg_32__35[] = {
	attrify(rx_low_edge_comp),
	attrify(rx_high_edge_comp),
	attrify(tx_low_edge_comp),
	attrify(tx_high_edge_comp),
	NULL,
};

static struct attribute *attrs_reg_36[] = {
	attrify(axis1_comp),
	NULL,
};

static struct attribute *attrs_reg_37[] = {
	attrify(axis2_comp),
	NULL,
};

static struct attribute *attrs_reg_38__40[] = {
	attrify(noise_control_1),
	attrify(noise_control_2),
	attrify(noise_control_3),
	NULL,
};

static struct attribute *attrs_reg_41[] = {
	attrify(no_signal_clarity),
	NULL,
};

static struct attribute *attrs_reg_57[] = {
	attrify(cbc_cap_0d),
	attrify(cbc_polarity_0d),
	attrify(cbc_tx_carrier_selection_0d),
	NULL,
};

static struct attribute_group attrs_ctrl_regs[] = {
	GROUP(attrs_reg_0),
	GROUP(attrs_reg_1),
	GROUP(attrs_reg_2),
	GROUP(attrs_reg_3),
	GROUP(attrs_reg_4__6),
	GROUP(attrs_reg_7),
	GROUP(attrs_reg_8__9),
	GROUP(attrs_reg_10),
	GROUP(attrs_reg_11),
	GROUP(attrs_reg_12__13),
	GROUP(attrs_reg_14__16),
	GROUP(attrs_reg_17__19),
	GROUP(attrs_reg_20),
	GROUP(attrs_reg_21),
	GROUP(attrs_reg_22__26),
	GROUP(attrs_reg_27),
	GROUP(attrs_reg_28),
	GROUP(attrs_reg_29),
	GROUP(attrs_reg_30),
	GROUP(attrs_reg_31),
	GROUP(attrs_reg_32__35),
	GROUP(attrs_reg_36),
	GROUP(attrs_reg_37),
	GROUP(attrs_reg_38__40),
	GROUP(attrs_reg_41),
	GROUP(attrs_reg_57),
};

static bool attrs_ctrl_regs_exist[ARRAY_SIZE(attrs_ctrl_regs)];

static struct bin_attribute dev_report_data = {
	.attr = {
		.name = "report_data",
		.mode = S_IRUGO,
	},
	.size = 0,
	.read = synaptics_rmi4_f54_data_read,
};

static struct synaptics_rmi4_f54_handle *f54;
static struct synaptics_rmi4_f55_handle *f55;

DECLARE_COMPLETION(f54_s3207_remove_complete);

static bool is_report_type_valid(enum f54_report_types report_type)
{
	switch (report_type) {
	case F54_8BIT_IMAGE:
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_HIGH_RESISTANCE:
	case F54_TX_TO_TX_SHORT:
	case F54_RX_TO_RX1:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP_MIN_MAX:
	case F54_RX_OPENS1:
	case F54_TX_OPEN:
	case F54_TX_TO_GROUND:
	case F54_RX_TO_RX2:
	case F54_RX_OPENS2:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
	case F54_SENSOR_SPEED:
	case F54_ADC_RANGE:
	case F54_TREX_OPENS:
	case F54_TREX_TO_GND:
	case F54_TREX_SHORTS:
		return true;
		break;
	default:
		f54->report_type = INVALID_REPORT_TYPE;
		f54->report_size = 0;
		return false;
	}
}

static void set_report_size(void)
{
	int retval;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	rx = f54->rx_assigned;
	tx = f54->tx_assigned;

	switch (f54->report_type) {
	case F54_8BIT_IMAGE:
		f54->report_size = rx * tx;
		break;
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
	case F54_SENSOR_SPEED:
		f54->report_size = 2 * rx * tx;
		break;
	case F54_HIGH_RESISTANCE:
		f54->report_size = HIGH_RESISTANCE_DATA_SIZE;
		break;
	case F54_TX_TO_TX_SHORT:
	case F54_TX_OPEN:
	case F54_TX_TO_GROUND:
		f54->report_size = 3;//(tx + 7) / 8;
		break;
	case F54_RX_TO_RX1:
	case F54_RX_OPENS1:
		if (rx < tx)
			f54->report_size = 2 * rx * rx;
		else
			f54->report_size = 2 * rx * tx;
		break;
	case F54_FULL_RAW_CAP_MIN_MAX:
		f54->report_size = FULL_RAW_CAP_MIN_MAX_DATA_SIZE;
		break;
	case F54_RX_TO_RX2:
	case F54_RX_OPENS2:
		if (rx <= tx)
			f54->report_size = 0;
		else
			f54->report_size = 2 * rx * (rx - tx);
		break;
	case F54_ADC_RANGE:
		if (f54->query.has_signal_clarity) {
			mutex_lock(&f54->control_mutex);
			retval = f54->fn_ptr->read(rmi4_data,
					f54->control.reg_41->address,
					f54->control.reg_41->data,
					sizeof(f54->control.reg_41->data));
			mutex_unlock(&f54->control_mutex);
			if (retval < 0) {
				TS_LOG_ERR("%s: Failed to read control reg_41\n",__func__);
				f54->report_size = 0;
				break;
			}
			if (!f54->control.reg_41->no_signal_clarity) {
				if (tx % 4)
					tx += 4 - (tx % 4);
			}
		}
		f54->report_size = 2 * rx * tx;
		break;
	case F54_TREX_OPENS:
	case F54_TREX_TO_GND:
	case F54_TREX_SHORTS:
		f54->report_size = TREX_DATA_SIZE;
		break;
	default:
		f54->report_size = 0;
	}

	return;
}



static int do_preparation(void)
{
	int retval;
	unsigned char value;
	unsigned char command;
	unsigned char timeout_count;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	mutex_lock(&f54->control_mutex);

	if (f54->query.touch_controller_family == 1) {
		value = 0;
		retval = f54->fn_ptr->write(rmi4_data,
				f54->control.reg_7->address,
				&value,
				sizeof(f54->control.reg_7->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable CBC\n",__func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	} else if (f54->query.has_ctrl88 == 1) {
		retval = f54->fn_ptr->read(rmi4_data,
				f54->control.reg_88->address,
				f54->control.reg_88->data,
				sizeof(f54->control.reg_88->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable CBC (read ctrl88)\n",__func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
		f54->control.reg_88->cbc_polarity = 0;
		f54->control.reg_88->cbc_tx_carrier_selection = 0;
		retval = f54->fn_ptr->write(rmi4_data,
				f54->control.reg_88->address,
				f54->control.reg_88->data,
				sizeof(f54->control.reg_88->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable CBC (write ctrl88)\n",__func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	}

	if (f54->query.has_0d_acquisition_control) {
		value = 0;
		retval = f54->fn_ptr->write(rmi4_data,
				f54->control.reg_57->address,
				&value,
				sizeof(f54->control.reg_57->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable 0D CBC\n",__func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	}

	if (f54->query.has_signal_clarity) {
		value = 1;
		retval = f54->fn_ptr->write(rmi4_data,
				f54->control.reg_41->address,
				&value,
				sizeof(f54->control.reg_41->data));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to disable signal clarity\n",__func__);
			mutex_unlock(&f54->control_mutex);
			return retval;
		}
	}

	mutex_unlock(&f54->control_mutex);

	command = (unsigned char)COMMAND_FORCE_UPDATE;

	retval = f54->fn_ptr->write(rmi4_data,
			f54->command_base_addr,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write force update command\n",__func__);
		return retval;
	}

	timeout_count = 0;
	do {
		retval = f54->fn_ptr->read(rmi4_data,
				f54->command_base_addr,
				&value,
				sizeof(value));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read command register\n",__func__);
			return retval;
		}

		if (value == 0x00)
			break;

		msleep(100);
		timeout_count++;
	} while (timeout_count < FORCE_TIMEOUT_100MS);

	if (timeout_count == FORCE_TIMEOUT_100MS) {
		TS_LOG_ERR("%s: Timed out waiting for force update\n",__func__);
		return -ETIMEDOUT;
	}

	command = (unsigned char)COMMAND_FORCE_CAL;

	retval = f54->fn_ptr->write(rmi4_data,
			f54->command_base_addr,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write force cal command\n",__func__);
		return retval;
	}

	timeout_count = 0;
	do {
		retval = f54->fn_ptr->read(rmi4_data,
				f54->command_base_addr,
				&value,
				sizeof(value));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read command register\n",__func__);
			return retval;
		}

		if (value == 0x00)
			break;

		msleep(100);
		timeout_count++;
	} while (timeout_count < FORCE_TIMEOUT_100MS);

	if (timeout_count == FORCE_TIMEOUT_100MS) {
		TS_LOG_ERR("%s: Timed out waiting for force cal\n",__func__);
		return -ETIMEDOUT;
	}

	return 0;
}

#ifdef WATCHDOG_HRTIMER
static void timeout_set_status(struct work_struct *work)
{
	int retval;
	unsigned char command;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	TS_LOG_INFO("watchdog timeout f54->status is %d\n",f54->status);

	mutex_lock(&f54->status_mutex);
	if (f54->status == STATUS_BUSY) {
		retval = f54->fn_ptr->read(rmi4_data,
				f54->command_base_addr,
				&command,
				sizeof(command));
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read command register\n",__func__);
		} else if (command & COMMAND_GET_REPORT) {
			TS_LOG_ERR("%s: Report type not supported by FW\n",__func__);
		} else {
			queue_delayed_work(f54->status_workqueue,
					&f54->status_work,
					0);
			mutex_unlock(&f54->status_mutex);
			return;
		}
		f54->report_type = INVALID_REPORT_TYPE;
		f54->report_size = 0;
		f54->status = STATUS_IDLE;
	}
	mutex_unlock(&f54->status_mutex);

	return;
}

static enum hrtimer_restart get_report_timeout(struct hrtimer *timer)
{
	TS_LOG_DEBUG("%s:in!\n", __func__);
	schedule_work(&(f54->timeout_work));

	return HRTIMER_NORESTART;
}
#endif

#ifdef RAW_HEX
static void print_raw_hex_report(void)
{
	unsigned int ii;

	pr_info("%s: Report data (raw hex)\n", __func__);

	switch (f54->report_type) {
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_HIGH_RESISTANCE:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP_MIN_MAX:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
	case F54_SENSOR_SPEED:
	case F54_ADC_RANGE:
		for (ii = 0; ii < f54->report_size; ii += 2) {
			pr_info("%03d: 0x%02x%02x\n",
					ii / 2,
					f54->report_data[ii + 1],
					f54->report_data[ii]);
		}
		break;
	default:
		for (ii = 0; ii < f54->report_size; ii++)
			pr_info("%03d: 0x%02x\n", ii, f54->report_data[ii]);
		break;
	}

	return;
}
#endif

#ifdef HUMAN_READABLE
static void print_image_report(void)
{
	unsigned int ii;
	unsigned int jj;
	short *report_data;

	switch (f54->report_type) {
	case F54_16BIT_IMAGE:
	case F54_RAW_16BIT_IMAGE:
	case F54_TRUE_BASELINE:
	case F54_FULL_RAW_CAP:
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
		pr_info("%s: Report data (image)\n", __func__);

		report_data = (short *)f54->report_data;

		for (ii = 0; ii < f54->tx_assigned; ii++) {
			for (jj = 0; jj < f54->rx_assigned; jj++) {
				if (*report_data < -64)
					pr_cont(".");
				else if (*report_data < 0)
					pr_cont("-");
				else if (*report_data > 64)
					pr_cont("*");
				else if (*report_data > 0)
					pr_cont("+");
				else
					pr_cont("0");

				report_data++;
			}
			pr_info("");
		}
		pr_info("%s: End of report\n", __func__);
		break;
	default:
		pr_info("%s: Image not supported for report type %d\n",
				__func__, f54->report_type);
	}

	return;
}
#endif

static void free_control_mem(void)
{
	struct f54_control control = f54->control;

	kfree(control.reg_0);
	kfree(control.reg_1);
	kfree(control.reg_2);
	kfree(control.reg_3);
	kfree(control.reg_4__6);
	kfree(control.reg_7);
	kfree(control.reg_8__9);
	kfree(control.reg_10);
	kfree(control.reg_11);
	kfree(control.reg_12__13);
	kfree(control.reg_14);
	kfree(control.reg_15);
	kfree(control.reg_16);
	kfree(control.reg_17);
	kfree(control.reg_18);
	kfree(control.reg_19);
	kfree(control.reg_20);
	kfree(control.reg_21);
	kfree(control.reg_22__26);
	kfree(control.reg_27);
	kfree(control.reg_28);
	kfree(control.reg_29);
	kfree(control.reg_30);
	kfree(control.reg_31);
	kfree(control.reg_32__35);
	kfree(control.reg_36);
	kfree(control.reg_37);
	kfree(control.reg_38);
	kfree(control.reg_39);
	kfree(control.reg_40);
	kfree(control.reg_41);
	kfree(control.reg_57);

	return;
}
/*
static void remove_sysfs(void)
{
	int reg_num;

	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);

	sysfs_remove_group(f54->attr_dir, &attr_group);

	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++)
		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);

	kobject_put(f54->attr_dir);

	return;
}
*/
static ssize_t synaptics_rmi4_f54_tp_status_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->status);
}

static ssize_t synaptics_rmi4_f54_report_size_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_size);
}

static ssize_t synaptics_rmi4_f54_no_auto_cal_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->no_auto_cal);
}

static ssize_t synaptics_rmi4_f54_no_auto_cal_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned char data;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting > 1)
		return -EINVAL;

	retval = f54->fn_ptr->read(rmi4_data,
			f54->control_base_addr,
			&data,
			sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control register\n",__func__);
		return retval;
	}

	if ((data & NO_AUTO_CAL_MASK) == setting)
		return count;

	data = (data & ~NO_AUTO_CAL_MASK) | (data & NO_AUTO_CAL_MASK);

	retval = f54->fn_ptr->write(rmi4_data,
			f54->control_base_addr,
			&data,
			sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write control register\n",__func__);
		return retval;
	}

	f54->no_auto_cal = (setting == 1);

	return count;
}

static ssize_t synaptics_rmi4_f54_report_type_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->report_type);
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static int synaptics_rmi4_f54_report_type_set(char setting)
{
	int retval = 0;
	unsigned char data;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	if (!is_report_type_valid((enum f54_report_types)setting)) {
		TS_LOG_ERR("%s: Report type not supported by driver\n",__func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_BUSY) {
		f54->report_type = (enum f54_report_types)setting;
		data = (unsigned char)setting;
		retval = f54->fn_ptr->write(rmi4_data,
				f54->data_base_addr,
				&data,
				sizeof(data));
		mutex_unlock(&f54->status_mutex);
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to write data register\n",__func__);
			return retval;
		}
		return 0;
	} else {
		TS_LOG_ERR("%s: Previous get report still ongoing\n",__func__);
		mutex_unlock(&f54->status_mutex);
		return -EINVAL;
	}
}
#endif

static ssize_t synaptics_rmi4_f54_report_type_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned char data;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (!is_report_type_valid((enum f54_report_types)setting)) {
		TS_LOG_ERR("%s: Report type not supported by driver\n",__func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_BUSY) {
		f54->report_type = (enum f54_report_types)setting;
		data = (unsigned char)setting;
		retval = f54->fn_ptr->write(rmi4_data,
				f54->data_base_addr,
				&data,
				sizeof(data));
		mutex_unlock(&f54->status_mutex);
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to write data register\n",__func__);
			return retval;
		}
		return count;
	} else {
		TS_LOG_ERR("%s: Previous get report still ongoing\n",__func__);
		mutex_unlock(&f54->status_mutex);
		return -EINVAL;
	}
}

static ssize_t synaptics_rmi4_f54_fifoindex_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int retval;
	unsigned char data[2];
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = f54->fn_ptr->read(rmi4_data,
			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
			data,
			sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read data registers\n",__func__);
		return retval;
	}

	batohs(&f54->fifoindex, data);

	return snprintf(buf, PAGE_SIZE, "%u\n", f54->fifoindex);
}
static ssize_t synaptics_rmi4_f54_fifoindex_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned char data[2];
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	f54->fifoindex = setting;

	hstoba(data, (unsigned short)setting);

	retval = f54->fn_ptr->write(rmi4_data,
			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
			data,
			sizeof(data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write data registers\n",__func__);
		return retval;
	}

	return count;
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static int synaptics_rmi4_f54_do_preparation_set(void)
{
	int retval;
	//struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n",__func__, f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",__func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}

	mutex_unlock(&f54->status_mutex);

	retval = do_preparation();
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to do preparation\n",__func__);
		return retval;
	}
	return 0;
}
#endif

static ssize_t synaptics_rmi4_f54_do_preparation_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned long setting;
	//struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n",__func__, f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",__func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}

	mutex_unlock(&f54->status_mutex);

	retval = do_preparation();
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to do preparation\n",__func__);
		return retval;
	}

	return count;
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static ssize_t synaptics_rmi4_f54_get_report_set(char setting)
{
	int retval;
	unsigned char command;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	if (setting != 1)
		return -EINVAL;

	command = (unsigned char)COMMAND_GET_REPORT;

	if (!is_report_type_valid(f54->report_type)) {
		TS_LOG_ERR("%s: Invalid report type\n",__func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n",__func__, f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",__func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}
	//TS_LOG_ERR("to set interrupt\n");
	//set_interrupt(true);

	f54->status = STATUS_BUSY;

	retval = f54->fn_ptr->write(rmi4_data,
			f54->command_base_addr,
			&command,
			sizeof(command));
	mutex_unlock(&f54->status_mutex);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write get report command\n",__func__);
		return retval;
	}

#ifdef WATCHDOG_HRTIMER
	hrtimer_start(&f54->watchdog,
			ktime_set(WATCHDOG_TIMEOUT_S, 0),
			HRTIMER_MODE_REL);
#endif

	return 0;
}
#endif

static ssize_t synaptics_rmi4_f54_get_report_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned char command;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	command = (unsigned char)COMMAND_GET_REPORT;

	if (!is_report_type_valid(f54->report_type)) {
		TS_LOG_ERR("%s: Invalid report type\n",__func__);
		return -EINVAL;
	}

	mutex_lock(&f54->status_mutex);

	if (f54->status != STATUS_IDLE) {
		if (f54->status != STATUS_BUSY) {
			TS_LOG_ERR("%s: Invalid status (%d)\n",__func__, f54->status);
		} else {
			TS_LOG_ERR("%s: Previous get report still ongoing\n",__func__);
		}
		mutex_unlock(&f54->status_mutex);
		return -EBUSY;
	}

	//set_interrupt(true);

	f54->status = STATUS_BUSY;

	retval = f54->fn_ptr->write(rmi4_data,
			f54->command_base_addr,
			&command,
			sizeof(command));
	mutex_unlock(&f54->status_mutex);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write get report command\n",__func__);
		return retval;
	}

#ifdef WATCHDOG_HRTIMER
	hrtimer_start(&f54->watchdog,
			ktime_set(WATCHDOG_TIMEOUT_S, 0),
			HRTIMER_MODE_REL);
#endif

	return count;
}

static ssize_t synaptics_rmi4_f54_force_cal_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned char command;
	unsigned long setting;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	command = (unsigned char)COMMAND_FORCE_CAL;

	if (f54->status == STATUS_BUSY)
		return -EBUSY;

	retval = f54->fn_ptr->write(rmi4_data,
			f54->command_base_addr,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write force cal command\n",__func__);
		return retval;
	}

	return count;
}

/*Add synaptics capacitor test function */
#ifdef MMITEST
static struct kobject *touch_screen_kobject_ts = NULL;

static struct kobject* tp_get_touch_screen_obj(void)
{
	if( NULL == touch_screen_kobject_ts )
	{
		touch_screen_kobject_ts = kobject_create_and_add("touch_screen", NULL);
		if (!touch_screen_kobject_ts)
		{
			TS_LOG_ERR("create touch_screen kobjetct error!\n");
			return NULL;
		}
		else
		{
			TS_LOG_INFO(" create sys/touch_screen successful!\n");
		}
	}
	else
	{
		TS_LOG_INFO("sys/touch_screen already exist!\n");
	}

	return touch_screen_kobject_ts;
}
static void mmi_rawimage_report(unsigned char *buffer)
{
 	int i, j, k=0;
	short *DataArray;
	short temp;
	enum mmi_results TestResult = TEST_PASS;
	char buf[6];
	memset(g_mmi_buf_f54raw_data, 0, (rx*tx*6+F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_mmi_buf_f54raw_data, "RawImageData:\n");

	DataArray = (short*)kmalloc(sizeof(short)*tx*rx, GFP_KERNEL);

	for (i = 0; i < tx; i++) {
	   	for (j = 0; j < rx; j++) {
			temp = buffer[k] | (buffer[k+1] << 8);
			DataArray[i*rx+j] = temp;	//float is not allowed in kernel space
			k = k + 2;

			sprintf(buf, "%d ", temp);
			strncat(g_mmi_buf_f54raw_data, buf ,sizeof(buf));
		}
		strncat(g_mmi_buf_f54raw_data, "\n", 1);
   	}

	for (i = 0; i < tx; i++) {
	   	for (j = 0; j < rx; j++) {
			if ((DataArray[i*rx+j] > FullRawCapUpperLimit[i*rx+j]) ||
				(DataArray[i*rx+j] < FullRawCapLowerLimit[i*rx+j])) {
				TestResult = TEST_FAILED;
				TS_LOG_ERR("%s: TEST_FAILED:1F-, RawCap(%d,%d) = %d \n",__func__,i,j,DataArray[i*rx+j]);
			}
	  	}
	}

	if (TestResult) {
	    strcat(g_mmi_buf_f54test_result,"1P-");
	}else{
	    strcat(g_mmi_buf_f54test_result,"1F-");
	    strncpy(tp_test_failed_reason,"panel_reason",TP_TEST_FAILED_REASON_LEN);
	}

	kfree(DataArray);
	return;
}

static int RxtoRx1ShortTest(unsigned char* buffer)
{

	int i, j, k=0;
	int count = 0;
	int DiagonalUpperLimit = RxDiagonalUpperLimit;
	int DiagonalLowerLimit = RxDiagonalLowerLimit;
	int OthersUpperLimit = RxOthersUpperLimit;
	short ImageArray;
	char buf[6] = {0};

	for (i = 0; i < tx; i++)
	{
		for (j = 0; j <rx; j++)
		{
	        	ImageArray = buffer[k]|(buffer[k+1] << 8);
			k = k + 2;
			sprintf(buf, "%5d ", ImageArray);

			if (i == j){
				strncat(g_mmi_RxtoRxshort_report, buf, sizeof(buf));
				if ((ImageArray <= DiagonalUpperLimit) && (ImageArray >= DiagonalLowerLimit))
				count++;
	        	}else{
				if (ImageArray <= OthersUpperLimit)
				count++;
			}
		}
		//strncat(g_mmi_RxtoRxshort_report, "\n", 1);
	}
	return count;
}

static int RxtoRx2ShortTest(unsigned char* buffer)
{

	int i, j, k=0;
	int count = 0;
	int DiagonalUpperLimit = RxDiagonalUpperLimit;
	int DiagonalLowerLimit = RxDiagonalLowerLimit;
	int OthersUpperLimit = RxOthersUpperLimit;
	short ImageArray;
	char buf[6] = {0};

	for (i = 0; i < (rx-tx); i++)
	{
		for (j = 0; j <rx; j++)
		{
	        	ImageArray = buffer[k]|(buffer[k+1] << 8);
			k = k + 2;
			sprintf(buf, "%5d ", ImageArray);

			if ((i+tx) == j){
				strncat(g_mmi_RxtoRxshort_report, buf, sizeof(buf));
				if((ImageArray <= DiagonalUpperLimit) && (ImageArray >= DiagonalLowerLimit))
					count++;
				else
					TS_LOG_ERR("%s: Failed,ImageArray(%d,%d) = %d\n",__func__,i,j,ImageArray);
			}else{
				if(ImageArray <= OthersUpperLimit)
					count++;
				else
					TS_LOG_ERR("%s: Failed,ImageArray(%d,%d) = %d\n",__func__,i,j,ImageArray);
			}
		}
		//strncat(g_mmi_RxtoRxshort_report, "\n", 1);
	}
	strncat(g_mmi_RxtoRxshort_report, "\n", 1);
	return count;
}

static void mmi_RxtoRxshort1_report(unsigned char* buffer)
{

	int count=0;
	//enum mmi_results TestResult = TEST_PASS;
	memset(g_mmi_RxtoRxshort_report, 0, (6*rx+F54_MAX_CAP_TITLE_SIZE));//only Diagonal for V3
	sprintf(g_mmi_RxtoRxshort_report, "RxtoRxshort:\n");

	count = RxtoRx1ShortTest(buffer);
	//count += RxtoRx2ShortTest(buffer);

	if(count == (rx * rx)){
	 	//TestResult = TEST_PASS;
	 	strcat(g_mmi_buf_f54test_result,"4P-");
	} else{
		//TestResult = TEST_FAILED;
	 	//strcat(g_mmi_buf_f54test_result,"4F-");
		TS_LOG_ERR("%s:test failed,count = %d LINE = %d\n",__func__,count,__LINE__);
	}

	return;
}

static void mmi_RxtoRxshort2_report(unsigned char* buffer)
{

	int count=tx*rx;
	//enum mmi_results TestResult = TEST_PASS;

	count += RxtoRx2ShortTest(buffer);

	if(count == (rx * rx)){
	 	//TestResult = TEST_PASS;
	 	strcat(g_mmi_buf_f54test_result,"4P-");
	} else{
		//TestResult = TEST_FAILED;
	 	strcat(g_mmi_buf_f54test_result,"4F-");
		strncpy(tp_test_failed_reason,"panel_reason",TP_TEST_FAILED_REASON_LEN);
	}

	return;
}

static void mmi_txtotx_short_report(unsigned char* buffer)
{
 	int i, j, index;
	int numberOfBytes = (f54->tx_assigned + 7) / 8;
	char val;
	enum mmi_results TestResult = TEST_PASS;

	for (i = 0; i < numberOfBytes; i++) {
		for (j = 0; j < 8; j++) {
			index =  i*8+j;
			if (index >= f54->tx_assigned)
				break;
			val = (buffer[i] & (1 << j)) >>j;
			if (numberOfBytes < tx) {
				if (val != TxTxReportLimit){
					TestResult = TEST_FAILED;
					TS_LOG_ERR("%s: Failed,val(%d,%d) = %d",__func__,i,j,val);
				}
			}
		}
   	}

	if (TestResult){
		strcat(g_mmi_buf_f54test_result,"2P-");
	}else{
		strcat(g_mmi_buf_f54test_result,"2F-");
		strncpy(tp_test_failed_reason,"panel_reason",TP_TEST_FAILED_REASON_LEN);
	}
	return;
}

static void mmi_txtoground_short_report(unsigned char* buffer, size_t report_size)
{
	//enum mmi_results TestResult = TEST_PASS;

	char Txstatus;
	int result = 0;
	int i,j;

	for (i = 0;i < report_size;i++)
	{
		for (j = 0; j < 8; j++)
		{
			Txstatus = (buffer[i] & (1 << j)) >> j;
				if (1 == Txstatus)
					result++;
			}
		}

		if ((tx) == result)
		{
			//TestResult = TEST_PASS;
			strcat(g_mmi_buf_f54test_result,"3P-");
		}
		else
		{
			TS_LOG_ERR("%s: Failed in txtoground, result = %d\n",__func__,result);
			//TestResult = TEST_FAILED;
			 strcat(g_mmi_buf_f54test_result,"3F-");
			strncpy(tp_test_failed_reason,"panel_reason",TP_TEST_FAILED_REASON_LEN);
		}

	return;
}

static void mmi_maxmincapacitance_report(unsigned char* buffer)
{
	//enum mmi_results TestResult = TEST_PASS;

    	short maxcapacitance = FullRawMaxCap;
	short mincapacitance = FullRawMinCap;
	short max = 0;
	short min = 0;
	char buf[2*6] = {0};
	memset(g_mmi_maxmincapacitance_report, 0, (2*6+F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_mmi_maxmincapacitance_report, "maxmincapacitance:\n");
	max = (buffer[0])|(buffer[1] << 8);
	min = (buffer[2])|(buffer[3] << 8);

	if ((max < maxcapacitance)&& (min > mincapacitance)){
		//TestResult = TEST_PASS;
		strcat(g_mmi_buf_f54test_result,"5P-");
	}else{
		//TestResult = TEST_FAILED;
		strcat(g_mmi_buf_f54test_result,"5F-");
		strncpy(tp_test_failed_reason,"panel_reason",TP_TEST_FAILED_REASON_LEN);
	}

	sprintf(buf, " %d %d", max, min);
	strncat(g_mmi_maxmincapacitance_report, buf, sizeof(buf));
	strncat(g_mmi_maxmincapacitance_report, "\n", 1);

	return;
}

static void mmi_highresistance_report(unsigned char* buffer)
{
	int i, k=0;
	short temp;
	enum mmi_results TestResult = TEST_PASS;
	short HighResistanceResult[3];
	char buf[6] = {0};
	memset(g_mmi_highresistance_report, 0, (3*6+F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_mmi_highresistance_report, "highresistance:\n");

	for (i = 0; i <3; i++, k+=2) {
		temp = buffer[k] | (buffer[k+1] << 8);
		HighResistanceResult[i] = temp;
		if ((HighResistanceResult[i] > HighResistanceUpperLimit[i]) ||
			(HighResistanceResult[i] < HighResistanceLowerLimit[i])) {

			TestResult = TEST_FAILED;
			TS_LOG_ERR("%s: TEST_FAILED: 6F ,highresistance[%d] = %d \n",__func__,i,HighResistanceResult[i]);
		}
		sprintf(buf, " %d ", HighResistanceResult[i]);
		strncat(g_mmi_highresistance_report, buf, sizeof(buf));
	}

	strncat(g_mmi_highresistance_report, "\n", 1);

	if(TestResult){
		strcat(g_mmi_buf_f54test_result,"6P-");
	}else{
		strcat(g_mmi_buf_f54test_result,"6F-");
		strncpy(tp_test_failed_reason,"panel_reason",TP_TEST_FAILED_REASON_LEN);
	}
	return;
}
static void mmi_delta_report(unsigned char *buffer)
{
 	int i, j, k=0;
	short *DataArray;
	short temp;
	char buf[6];
	TS_LOG_INFO("mmi_delta_report\n");
	memset(g_buf_debug_data, 1, (rx*tx*6+F54_MAX_CAP_TITLE_SIZE+F54_MAX_CAP_TITLE_SIZE+F54_MAX_CAP_TITLE_SIZE));
	sprintf(g_buf_debug_data, "delta_data:\n");

	DataArray = (short*)kmalloc(sizeof(short)*tx*rx, GFP_KERNEL);

	for (i = 0; i < tx; i++) {
		for (j = 0; j < rx; j++) {
			temp = buffer[k] | (buffer[k+1] << 8);
			DataArray[i*rx+j] = temp;	//float is not allowed in kernel space
			k = k + 2;

			sprintf(buf, "%d ", temp);
			strncat(g_buf_debug_data, buf ,sizeof(buf));
		}
		strcat(g_buf_debug_data,"\n");
	}

	kfree(DataArray);
	return;
}
static int mmi_runtest(int report_type)
{
	int retval = 0;
	unsigned char patience = 10;
	int report_size;
	unsigned char *buffer = NULL;
	unsigned char command;
	//struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	//TS_LOG_INFO("mmi test report type is %d",report_type);

	retval = synaptics_rmi4_f54_report_type_set(report_type);
	if (retval)
		goto test_exit;
	mdelay(5);
	retval = synaptics_rmi4_f54_get_report_set(1);
	if (retval)
	{
		TS_LOG_ERR("synaptics_rmi4_f54_get_report_set failed  retval=%d",retval);
		goto test_exit;
	}
	while(patience!=0)
	{
		msleep(150);
		retval = f54->fn_ptr->read(f54->rmi4_data,
				f54->command_base_addr,
				&command,
				sizeof(command));
		if (retval)
		{
			TS_LOG_ERR("read command failed  retval=%d",retval);
			continue;
		}
		TS_LOG_DEBUG("command=%d",command);
		if(0==(command&0x01))
		{
			break;
		}
		patience--;
	}
	retval = synaptics_rmi4_f54_attention();
	if(retval)
	{
		TS_LOG_ERR("synaptics_rmi4_f54_attention failed  retval=%d",retval);
		goto test_exit;
	}

	report_size = f54->report_size;

	TS_LOG_INFO("mmi test report type is %d,report_size is %d,patience=%d, status=%d\n",report_type,report_size,patience, f54->status);

	if (!report_size)
		goto test_exit;
	buffer = kmalloc(report_size, GFP_KERNEL);
	if (!buffer){
		TS_LOG_ERR( "%s: Faild to kzalloc %d buffer\n",__func__, report_size);
		goto test_exit;
	}
	memset(buffer, 0, report_size);

	//load test limit
	//LoadHighResistanceLimits();

	//simulate ReadBlockData()
	mutex_lock(&f54->data_mutex);

	if (f54->report_data) {
		memcpy(buffer, f54->report_data, f54->report_size);
		mutex_unlock(&f54->data_mutex);
	} else {
		mutex_unlock(&f54->data_mutex);
		goto test_exit;
	}
	switch (report_type) {
	case F54_FULL_RAW_CAP_MIN_MAX:
		if  (!g_mmi_maxmincapacitance_report)
			g_mmi_maxmincapacitance_report = kmalloc(2*6+F54_MAX_CAP_TITLE_SIZE, GFP_KERNEL);
		mmi_maxmincapacitance_report(buffer);
		break;
	case F54_FULL_RAW_CAP_RX_COUPLING_COMP:
		if  (!g_mmi_buf_f54raw_data)
			g_mmi_buf_f54raw_data = kmalloc(rx*tx*6+F54_MAX_CAP_TITLE_SIZE  , GFP_KERNEL);
		mmi_rawimage_report(buffer);
		break;
	case F54_TX_TO_TX_SHORT:
		mmi_txtotx_short_report(buffer);
		break;
	case F54_HIGH_RESISTANCE:
		if  (!g_mmi_highresistance_report)
			g_mmi_highresistance_report = kmalloc(3*6+F54_MAX_CAP_TITLE_SIZE, GFP_KERNEL);
		mmi_highresistance_report(buffer);
		break;
	case F54_TX_TO_GROUND:
		mmi_txtoground_short_report(buffer, report_size);
		break;
	case F54_RX_TO_RX1:
		if  (!g_mmi_RxtoRxshort_report)
			g_mmi_RxtoRxshort_report = kmalloc(6*rx+F54_MAX_CAP_TITLE_SIZE, GFP_KERNEL);
		mmi_RxtoRxshort1_report(buffer);
		break;
	case F54_RX_TO_RX2:
		//g_mmi_RxtoRxshort_report = kmalloc(4536, GFP_KERNEL);
		mmi_RxtoRxshort2_report(buffer);
		break;
	case F54_16BIT_IMAGE:
		if  (!g_buf_debug_data)
			g_buf_debug_data = kmalloc(rx*tx*6+F54_MAX_CAP_TITLE_SIZE+ 4 * F54_MAX_CAP_TITLE_SIZE , GFP_KERNEL);//buf len for test
		mmi_delta_report(buffer);
		break;
	default:
		break;
	}
	kfree(buffer);
	return 0;

test_exit:
	TS_LOG_ERR("%s: Faild to run test\n",__func__);
	if (buffer)
		kfree(buffer);
	return -EINVAL;

}
static int synaptics_rmi4_irq_enable(bool enable)
{
	int retval = 0;

	unsigned short reg_addr = Interrupt_Enable_Addr;
	unsigned char  reg_data;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	TS_LOG_INFO("%s;enable =%d\n", __func__,enable);
	retval = f54->fn_ptr->read(rmi4_data,
					reg_addr,
					&reg_data,
					sizeof(reg_data));

	if (retval < 0) {
		TS_LOG_ERR("Failed to read reg, error = %d\n", retval);
		return retval;
	}

	if (IRQ_ON == enable) {
		reg_data |= IRQ_ENA_MASK_BIT;
	} else {
		reg_data &= ~IRQ_ENA_MASK_BIT;
	}

	retval = f54->fn_ptr->write(rmi4_data,
			reg_addr,
			&reg_data,
			sizeof(reg_data));

	if (retval < 0) {
		TS_LOG_ERR("Failed to write reg, error = %d\n", retval);
	}
	return retval;
}
static ssize_t synaptics_rmi4_f54_mmi_test_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int retval = 0;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	TS_LOG_ERR("begin mmi test.\n");

	atomic_set(&g_ts_data.state, TS_MMI_CAP_TEST);
	if (!g_mmi_buf_f54test_result)
		g_mmi_buf_f54test_result = kmalloc(80, GFP_KERNEL);

	if (g_mmi_buf_f54test_result)
		memset(g_mmi_buf_f54test_result, 0, 80);
	else
		goto exit;
	retval = synaptics_rmi4_irq_enable(IRQ_OFF);
	retval = synaptics_rmi4_f54_do_preparation_set();
	if (retval)
		{
			TS_LOG_ERR("fail to do preparation set\n");
			goto exit;
		}
	sprintf(g_mmi_buf_f54test_result, "0P-");

	retval = mmi_runtest(F54_HIGH_RESISTANCE);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_FULL_RAW_CAP_MIN_MAX);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_FULL_RAW_CAP_RX_COUPLING_COMP);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_RX_TO_RX1);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_RX_TO_RX2);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_TX_TO_GROUND);
	if (retval)
		goto exit;

	retval = mmi_runtest(F54_TX_TO_TX_SHORT);
	if (retval)
		goto exit;
	if (0 == strlen(g_mmi_buf_f54test_result) || strstr(g_mmi_buf_f54test_result, "F")){
		strncat(g_mmi_buf_f54test_result, tp_test_failed_reason, 50);
	}

	switch(f54->rmi4_data->synaptics_chip_data->ic_type) {
		case SYNAPTICS_S3207:
			strncat(g_mmi_buf_f54test_result, "-synaptics_3207", strlen("-synaptics_3207"));
			break;
		case SYNAPTICS_S3350:
			strncat(g_mmi_buf_f54test_result, "-synaptics_3350", strlen("-synaptics_3350"));
			break;
		case SYNAPTICS_S3320:
			strncat(g_mmi_buf_f54test_result, "-synaptics_3320", strlen("-synaptics_3320"));
			break;
		case SYNAPTICS_S3718:
			strncat(g_mmi_buf_f54test_result, "-synaptics_3718", strlen("-synaptics_3718"));
			break;
		default:
			TS_LOG_ERR("failed to recognize ic_ver\n");
			break;
		}
	
	retval = synaptics_rmi4_irq_enable(IRQ_ON);
	sysfs_is_busy = true;
	f54->rmi4_data->reset_device(rmi4_data);
	atomic_set(&g_ts_data.state, TS_WORK);
	return 1;
exit:
	retval = synaptics_rmi4_irq_enable(IRQ_ON);
	sysfs_is_busy = true;
	f54->rmi4_data->reset_device(rmi4_data);
	strcat(g_mmi_buf_f54test_result,"0F-software_reason");
	TS_LOG_ERR("%s: Failed to run mmi test\n",
			__func__);
	atomic_set(&g_ts_data.state, TS_WORK);
	return 0;
}
static int read_debug_reg_status(unsigned char *buffer)
{
	int retval = 0;
	unsigned char command;
	char buf[6];

	TS_LOG_ERR("read_debug_reg_status_begin\n");
	retval = f54->fn_ptr->read(f54->rmi4_data,
			0x0051,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0051 \n",__func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0051");
	}
    else{
	TS_LOG_INFO("Device Control1=0x%x\n",command);
	strcat(g_buf_debug_data, "Device Control1:");
	sprintf(buf, "0x%x ", command);
	strncat(g_buf_debug_data, buf,sizeof(buf));
    }
	retval = f54->fn_ptr->read(f54->rmi4_data,
			0x0052,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0052 \n",__func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0052");
	}
	else{
	TS_LOG_INFO("Interrupt Enable=0x%x\n",command);
	strcat(g_buf_debug_data, "Interrupt Enable:");
	sprintf(buf, "0x%x ", command);
	strncat(g_buf_debug_data, buf,sizeof(buf));
	}

	retval = f54->fn_ptr->read(f54->rmi4_data,
			0x0013,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0013 \n",__func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0013");
	}
    else{
	TS_LOG_INFO("Device Status=0x%x\n",command);
	strcat(g_buf_debug_data, "Device Status:");
	sprintf(buf, "0x%x ", command);
	strncat(g_buf_debug_data, buf,sizeof(buf));
    }

	retval = f54->fn_ptr->read(f54->rmi4_data,
			0x0014,
			&command,
			sizeof(command));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control 0x0014 \n",__func__);
		strcat(g_buf_debug_data, "Failed to read control 0x0014");
	}
	else{
	TS_LOG_INFO("Interrupt Status=0x%x\n",command);
	strcat(g_buf_debug_data, "Interrupt Status:");
	sprintf(buf, "0x%x ", command);
	strncat(g_buf_debug_data, buf,sizeof(buf));
	strncat(g_buf_debug_data, "\0", 1);
	}

	return retval;
}

static int read_debug_power_pin_status(unsigned char *buffer)
{
	int retval = 0;
	unsigned char command;
	char buf[10];

	retval = gpio_get_value(f54->rmi4_data->synaptics_chip_data->reset_gpio);
	if (retval < 0) {
		TS_LOG_ERR("failed to get reset_gpio %s\n", retval);
		strcat(g_buf_debug_data, "failed to get reset_gpio");
	}
	else
	{
		TS_LOG_INFO("reset_gpio=%d\n",retval);
		strcat(g_buf_debug_data, "reset_gpio value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf,sizeof(buf));
	}
	retval = gpio_get_value(f54->rmi4_data->synaptics_chip_data->irq_gpio);
	if (retval < 0) {
		TS_LOG_ERR("failed to get irq_gpio %s\n", retval);
		strcat(g_buf_debug_data, "failed to get irq_gpio");
	}
	else
	{
		TS_LOG_INFO("irq_gpio=%d\n",retval);
		strcat(g_buf_debug_data, "irq_gpio value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf,sizeof(buf));
	}

	retval = gpio_get_value(f54->rmi4_data->synaptics_chip_data->vci_gpio_ctrl);
	if (retval < 0) {
		TS_LOG_ERR("failed to get vci_gpio_ctrl %s\n", retval);
		strcat(g_buf_debug_data, "failed to get vci_gpio_ctrl");
	}
	else
	{
		TS_LOG_INFO("vci_gpio_ctrl=%d\n",retval);
		strcat(g_buf_debug_data, "vci_gpio_ctrl value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf,sizeof(buf));
	}

	retval = gpio_get_value(f54->rmi4_data->synaptics_chip_data->vddio_gpio_ctrl);
	if (retval < 0) {
		TS_LOG_ERR("failed to get vddio_gpio_ctrl %s\n", retval);
		strcat(g_buf_debug_data, "failed to get vddio_gpio_ctrl");
	}
	else
	{
		TS_LOG_INFO("vddio_gpio_ctrl=%d\n",retval);
		strcat(g_buf_debug_data, "vddio_gpio_ctrl value is:");
		sprintf(buf, "0x%x ", retval);
		strncat(g_buf_debug_data, buf,sizeof(buf));
	}

	strcat(g_buf_debug_data, "g_ts_data.state is:");
	sprintf(buf, "%d ", atomic_read(&g_ts_data.state));
	strncat(g_buf_debug_data, buf,sizeof(buf));

	return retval;
}
static ssize_t synaptics_rmi4_f54_debug_test_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int retval = 0;
	int len = 0;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	TS_LOG_INFO("begin debug test.\n");

	if ((TS_SLEEP == atomic_read(&g_ts_data.state))||(TS_MMI_CAP_TEST == atomic_read(&g_ts_data.state))) 
	{
		TS_LOG_INFO("tp state unsupport debug.g_ts_data.state is %d\n",g_ts_data.state);
		return 0;
	}
	atomic_set(&g_ts_data.state, TS_MMI_CAP_TEST);
	retval = mmi_runtest(F54_16BIT_IMAGE);
	if (retval)
	{
		TS_LOG_ERR("fail to do F54_16BIT_IMAGE test\n");
	}

	retval = read_debug_reg_status(g_buf_debug_data);
	if (retval < 0)
	{
		TS_LOG_ERR("fail to do read_debug_reg_status test\n");
	}
	retval = read_debug_power_pin_status(g_buf_debug_data);
	if (retval < 0)
	{
		TS_LOG_ERR("fail to do read_debug_power_pin_status test\n");
	}


	sysfs_is_busy = true;
	f54->rmi4_data->reset_device(rmi4_data);

	if (NULL!=g_buf_debug_data){
		len = strlen(g_buf_debug_data);
		memcpy (buf, g_buf_debug_data, len+1);
		strcat(buf,"\0");
		TS_LOG_INFO("%s\n",buf);
	}
	else{
		TS_LOG_INFO("read debug data error\n");
	}
	if (NULL!=g_buf_debug_data){
        kfree(g_buf_debug_data);
	}
    atomic_set(&g_ts_data.state, TS_WORK);
	return len;
}
static ssize_t synaptics_rmi4_f54_mmi_test_result_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int len =0;
	TS_LOG_INFO("%s begin \n", __func__);
	if (NULL!=g_mmi_buf_f54test_result){
		len = strlen(g_mmi_buf_f54test_result);
		memcpy (buf, g_mmi_buf_f54test_result, len+1);
		strcat(buf,"\n");
	}
	else
		goto exit;

	if ((NULL!=g_mmi_buf_f54raw_data)&&(NULL!=g_mmi_highresistance_report)
		&&(NULL!=g_mmi_maxmincapacitance_report)&&(NULL!=g_mmi_RxtoRxshort_report)){
			strcat(buf, g_mmi_buf_f54raw_data);
			strcat(buf, g_mmi_highresistance_report);
			strcat(buf, g_mmi_maxmincapacitance_report);
			strcat(buf, g_mmi_RxtoRxshort_report);
			strcat(buf, "\0");

			len = strlen(g_mmi_buf_f54test_result) + strlen(g_mmi_buf_f54raw_data) + 1
				+ strlen(g_mmi_highresistance_report) + strlen(g_mmi_maxmincapacitance_report)
				+ strlen(g_mmi_RxtoRxshort_report);
		}
	exit:
	return len;
}
static ssize_t hw_synaptics_mmi_test_show(struct kobject *dev,
		struct kobj_attribute *attr, const char *buf)
{
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	struct device *cdev = &rmi4_data->input_dev->dev;
	if (!cdev){
		TS_LOG_ERR("device is null\n");
		return -EINVAL;
	}
	return synaptics_rmi4_f54_mmi_test_show(cdev, NULL, buf);
}
static ssize_t hw_synaptics_debug_test_show(struct kobject *dev,
		struct kobj_attribute *attr, const char *buf)
{
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	struct device *cdev = &rmi4_data->input_dev->dev;
	if (!cdev){
		TS_LOG_ERR("device is null\n");
		return -EINVAL;
	}
	return synaptics_rmi4_f54_debug_test_show(cdev, NULL, buf);
}
static ssize_t hw_synaptics_trigger_log_show(struct kobject *dev,
		struct kobj_attribute *attr, const char *buf)
{
	TS_LOG_ERR("g_synaptics_trigger_log_flag show is %d\n",g_synaptics_trigger_log_flag);

	return sprintf(buf, "%d\n", g_synaptics_trigger_log_flag);
}
static ssize_t hw_synaptics_trigger_log_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned long setting;


	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	g_synaptics_trigger_log_flag = setting;
	
	TS_LOG_ERR("g_synaptics_trigger_log_flag store is %d\n",g_synaptics_trigger_log_flag);

	return count;
}

static ssize_t hw_synaptics_mmi_test_result_show(struct kobject *dev,
		struct kobj_attribute *attr, char *buf)
{
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	struct device *cdev = &rmi4_data->input_dev->dev;
	if (!cdev){
		TS_LOG_ERR("device is null\n");
		return -EINVAL;
	}
	return synaptics_rmi4_f54_mmi_test_result_show(cdev, NULL, buf);
}
static struct kobj_attribute synaptics_mmi_test_v = {
	.attr = {.name = "tp_legacy_capacitance_test", .mode = 0664},
	.show = hw_synaptics_mmi_test_show,
	.store = NULL,
};
static struct kobj_attribute synaptics_mmi_test_result_v = {
	.attr = {.name = "tp_legacy_capacitance_data", .mode = 0444},
	.show = hw_synaptics_mmi_test_result_show,
	.store = NULL,
};
static struct kobj_attribute synaptics_debug_test_v = {
	.attr = {.name = "synaptics_debug_test", .mode = 0664},
	.show = hw_synaptics_debug_test_show,
	.store = NULL,
};
static struct kobj_attribute synaptics_trigger_log_v = {
	.attr = {.name = "synaptics_trigger_log", .mode = 0664},
	.show = hw_synaptics_trigger_log_show,
	.store = hw_synaptics_trigger_log_store,
};

static int add_synaptics_mmi_test_interfaces(struct device *dev)
{
	int error = 0;
	static int flag = 0;
	struct kobject *properties_kobj;

	if(0 != flag){
		return 0;
	}

	TS_LOG_INFO("%s: in!\n", __func__);
	properties_kobj = tp_get_touch_screen_obj();
	if( NULL == properties_kobj )
	{
		TS_LOG_ERR("Error, get kobj failed!\n");
		return -1;
	}

	/*add the node synaptics_mmi_test_result for apk to read*/
	error = sysfs_create_file(properties_kobj, &synaptics_mmi_test_result_v.attr);
	if (error)
	{
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_mmi_test_result create file error = %d\n", error);
		return -ENODEV;
	}

	/*add the node synaptics_mmi_test apk to write*/
	error = sysfs_create_file(properties_kobj, &synaptics_mmi_test_v.attr);
	if (error)
	{
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_mmi_test create file error\n");
		return -ENODEV;
	}
	error = sysfs_create_file(properties_kobj, &synaptics_debug_test_v.attr);
	if (error)
	{
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_mmi_test create file error\n");
		return -ENODEV;
	}
	error = sysfs_create_file(properties_kobj, &synaptics_trigger_log_v.attr);
	if (error)
	{
		kobject_put(properties_kobj);
		TS_LOG_ERR("synaptics_trigger_log create file error\n");
		return -ENODEV;
	}

	flag = 1;
	return 0;
}

#endif

static ssize_t synaptics_rmi4_f54_resume_touch_store(struct device *dev,
		struct device_attribute *attr, const char *buf, size_t count)
{
	int retval;
	unsigned long setting;

	retval = sstrtoul(buf, 10, &setting);
	if (retval)
		return retval;

	if (setting != 1)
		return -EINVAL;

	//set_interrupt(false);

	return count;
}

static ssize_t synaptics_rmi4_f54_num_of_mapped_rx_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->rx_assigned);
}

static ssize_t synaptics_rmi4_f54_num_of_mapped_tx_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	return snprintf(buf, PAGE_SIZE, "%u\n", f54->tx_assigned);
}

simple_show_func_unsigned(query, num_of_rx_electrodes)
simple_show_func_unsigned(query, num_of_tx_electrodes)
simple_show_func_unsigned(query, has_image16)
simple_show_func_unsigned(query, has_image8)
simple_show_func_unsigned(query, has_baseline)
simple_show_func_unsigned(query, clock_rate)
simple_show_func_unsigned(query, touch_controller_family)
simple_show_func_unsigned(query, has_pixel_touch_threshold_adjustment)
simple_show_func_unsigned(query, has_sensor_assignment)
simple_show_func_unsigned(query, has_interference_metric)
simple_show_func_unsigned(query, has_sense_frequency_control)
simple_show_func_unsigned(query, has_firmware_noise_mitigation)
simple_show_func_unsigned(query, has_two_byte_report_rate)
simple_show_func_unsigned(query, has_one_byte_report_rate)
simple_show_func_unsigned(query, has_relaxation_control)
simple_show_func_unsigned(query, curve_compensation_mode)
simple_show_func_unsigned(query, has_iir_filter)
simple_show_func_unsigned(query, has_cmn_removal)
simple_show_func_unsigned(query, has_cmn_maximum)
simple_show_func_unsigned(query, has_touch_hysteresis)
simple_show_func_unsigned(query, has_edge_compensation)
simple_show_func_unsigned(query, has_per_frequency_noise_control)
simple_show_func_unsigned(query, has_signal_clarity)
simple_show_func_unsigned(query, number_of_sensing_frequencies)

show_store_func_unsigned(control, reg_0, no_relax)
show_store_func_unsigned(control, reg_0, no_scan)
show_store_func_unsigned(control, reg_1, bursts_per_cluster)
show_store_func_unsigned(control, reg_2, saturation_cap)
show_store_func_unsigned(control, reg_3, pixel_touch_threshold)
show_store_func_unsigned(control, reg_4__6, rx_feedback_cap)
show_store_func_unsigned(control, reg_4__6, low_ref_cap)
show_store_func_unsigned(control, reg_4__6, low_ref_feedback_cap)
show_store_func_unsigned(control, reg_4__6, low_ref_polarity)
show_store_func_unsigned(control, reg_4__6, high_ref_cap)
show_store_func_unsigned(control, reg_4__6, high_ref_feedback_cap)
show_store_func_unsigned(control, reg_4__6, high_ref_polarity)
show_store_func_unsigned(control, reg_7, cbc_cap)
show_store_func_unsigned(control, reg_7, cbc_polarity)
show_store_func_unsigned(control, reg_7, cbc_tx_carrier_selection)
show_store_func_unsigned(control, reg_8__9, integration_duration)
show_store_func_unsigned(control, reg_8__9, reset_duration)
show_store_func_unsigned(control, reg_10, noise_sensing_bursts_per_image)
show_store_func_unsigned(control, reg_12__13, slow_relaxation_rate)
show_store_func_unsigned(control, reg_12__13, fast_relaxation_rate)
show_store_func_unsigned(control, reg_14, rxs_on_xaxis)
show_store_func_unsigned(control, reg_14, curve_comp_on_txs)
show_store_func_unsigned(control, reg_20, disable_noise_mitigation)
show_store_func_unsigned(control, reg_21, freq_shift_noise_threshold)
show_store_func_unsigned(control, reg_22__26, medium_noise_threshold)
show_store_func_unsigned(control, reg_22__26, high_noise_threshold)
show_store_func_unsigned(control, reg_22__26, noise_density)
show_store_func_unsigned(control, reg_22__26, frame_count)
show_store_func_unsigned(control, reg_27, iir_filter_coef)
show_store_func_unsigned(control, reg_28, quiet_threshold)
show_store_func_unsigned(control, reg_29, cmn_filter_disable)
show_store_func_unsigned(control, reg_30, cmn_filter_max)
show_store_func_unsigned(control, reg_31, touch_hysteresis)
show_store_func_unsigned(control, reg_32__35, rx_low_edge_comp)
show_store_func_unsigned(control, reg_32__35, rx_high_edge_comp)
show_store_func_unsigned(control, reg_32__35, tx_low_edge_comp)
show_store_func_unsigned(control, reg_32__35, tx_high_edge_comp)
show_store_func_unsigned(control, reg_41, no_signal_clarity)
show_store_func_unsigned(control, reg_57, cbc_cap_0d)
show_store_func_unsigned(control, reg_57, cbc_polarity_0d)
show_store_func_unsigned(control, reg_57, cbc_tx_carrier_selection_0d)

show_replicated_func_unsigned(control, reg_15, sensor_rx_assignment)
show_replicated_func_unsigned(control, reg_16, sensor_tx_assignment)
show_replicated_func_unsigned(control, reg_17, disable)
show_replicated_func_unsigned(control, reg_17, filter_bandwidth)
show_replicated_func_unsigned(control, reg_19, stretch_duration)
show_replicated_func_unsigned(control, reg_38, noise_control_1)
show_replicated_func_unsigned(control, reg_39, noise_control_2)
show_replicated_func_unsigned(control, reg_40, noise_control_3)

show_store_replicated_func_unsigned(control, reg_36, axis1_comp)
show_store_replicated_func_unsigned(control, reg_37, axis2_comp)

static ssize_t synaptics_rmi4_f54_burst_count_show(struct device *dev,
		struct device_attribute *attr, char *buf)
{
	int retval;
	int size = 0;
	unsigned char ii;
	unsigned char *temp;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	mutex_lock(&f54->control_mutex);

	retval = f54->fn_ptr->read(rmi4_data,
			f54->control.reg_17->address,
			(unsigned char *)f54->control.reg_17->data,
			f54->control.reg_17->length);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control reg_17\n",__func__);
	}

	retval = f54->fn_ptr->read(rmi4_data,
			f54->control.reg_18->address,
			(unsigned char *)f54->control.reg_18->data,
			f54->control.reg_18->length);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read control reg_18\n",__func__);
	}

	mutex_unlock(&f54->control_mutex);

	temp = buf;

	for (ii = 0; ii < f54->control.reg_17->length; ii++) {
		retval = snprintf(temp, PAGE_SIZE - size, "%u ", (1 << 8) *
			f54->control.reg_17->data[ii].burst_count_b8__10 +
			f54->control.reg_18->data[ii].burst_count_b0__7);
		if (retval < 0) {
			TS_LOG_ERR("%s: Faild to write output\n",__func__);
			return retval;
		}
		size += retval;
		temp += retval;
	}

	retval = snprintf(temp, PAGE_SIZE - size, "\n");
	if (retval < 0) {
		TS_LOG_ERR("%s: Faild to write null terminator\n",__func__);
		return retval;
	}

	return size + retval;
}

static ssize_t synaptics_rmi4_f54_data_read(struct file *data_file,
		struct kobject *kobj, struct bin_attribute *attributes,
		char *buf, loff_t pos, size_t count)
{
	//struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	mutex_lock(&f54->data_mutex);

	if (count < f54->report_size) {
		TS_LOG_ERR("%s: Report type %d data size (%d) too large\n",__func__, f54->report_type, f54->report_size);
		mutex_unlock(&f54->data_mutex);
		return -EINVAL;
	}

	if (f54->report_data) {
		memcpy(buf, f54->report_data, f54->report_size);
		mutex_unlock(&f54->data_mutex);
		return f54->report_size;
	} else {
		TS_LOG_ERR("%s: Report type %d data not available\n",__func__, f54->report_type);
		mutex_unlock(&f54->data_mutex);
		return -EINVAL;
	}
}

static int synaptics_rmi4_f54_set_sysfs(void)
{
	int retval;
	int reg_num;
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	TS_LOG_INFO("%s: in!\n", __func__);
	f54->attr_dir = kobject_create_and_add("f54",
			&rmi4_data->input_dev->dev.kobj);
	if (!f54->attr_dir) {
		TS_LOG_ERR("%s: Failed to create sysfs directory\n",__func__);
		goto exit_1;
	}

	retval = sysfs_create_bin_file(f54->attr_dir, &dev_report_data);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to create sysfs bin file\n",__func__);
		goto exit_2;
	}

	retval = sysfs_create_group(f54->attr_dir, &attr_group);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to create sysfs attributes\n",__func__);
		goto exit_3;
	}

	for (reg_num = 0; reg_num < ARRAY_SIZE(attrs_ctrl_regs); reg_num++) {
		if (attrs_ctrl_regs_exist[reg_num]) {
			retval = sysfs_create_group(f54->attr_dir,
					&attrs_ctrl_regs[reg_num]);
			if (retval < 0) {
				TS_LOG_ERR("%s: Failed to create sysfs attributes\n",__func__);
				goto exit_4;
			}
		}
	}

	retval = add_synaptics_mmi_test_interfaces(&rmi4_data->input_dev->dev);
	if (retval < 0) {
		TS_LOG_ERR( "Error, synaptics_mmi_test init sysfs fail! \n");
		goto exit_4;
	}

	return 0;

exit_4:
	sysfs_remove_group(f54->attr_dir, &attr_group);

	for (reg_num--; reg_num >= 0; reg_num--)
		sysfs_remove_group(f54->attr_dir, &attrs_ctrl_regs[reg_num]);

exit_3:
	sysfs_remove_bin_file(f54->attr_dir, &dev_report_data);

exit_2:
	kobject_put(f54->attr_dir);

exit_1:
	return -ENODEV;
}

static int synaptics_rmi4_f54_set_ctrl(void)
{
	unsigned char length = 0;
	unsigned char reg_num = 0;
	unsigned char num_of_sensing_freqs;
	unsigned short reg_addr = f54->control_base_addr;
	struct f54_control *control = &f54->control;
	//struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;

	num_of_sensing_freqs = f54->query.number_of_sensing_frequencies;

	/* control 0 */
	attrs_ctrl_regs_exist[reg_num] = true;
	control->reg_0 = kzalloc(sizeof(*(control->reg_0)),
			GFP_KERNEL);
	if (!control->reg_0)
		goto exit_no_mem;
	control->reg_0->address = reg_addr;
	reg_addr += sizeof(control->reg_0->data);
	reg_num++;

	/* control 1 */
	if ((f54->query.touch_controller_family == 0) ||
			(f54->query.touch_controller_family == 1)) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_1 = kzalloc(sizeof(*(control->reg_1)),
				GFP_KERNEL);
		if (!control->reg_1)
			goto exit_no_mem;
		control->reg_1->address = reg_addr;
		reg_addr += sizeof(control->reg_1->data);
	}
	reg_num++;

	/* control 2 */
	attrs_ctrl_regs_exist[reg_num] = true;
	control->reg_2 = kzalloc(sizeof(*(control->reg_2)),
			GFP_KERNEL);
	if (!control->reg_2)
		goto exit_no_mem;
	control->reg_2->address = reg_addr;
	reg_addr += sizeof(control->reg_2->data);
	reg_num++;

	/* control 3 */
	if (f54->query.has_pixel_touch_threshold_adjustment == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_3 = kzalloc(sizeof(*(control->reg_3)),
				GFP_KERNEL);
		if (!control->reg_3)
			goto exit_no_mem;
		control->reg_3->address = reg_addr;
		reg_addr += sizeof(control->reg_3->data);
	}
	reg_num++;

	/* controls 4 5 6 */
	if ((f54->query.touch_controller_family == 0) ||
			(f54->query.touch_controller_family == 1)) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_4__6 = kzalloc(sizeof(*(control->reg_4__6)),
				GFP_KERNEL);
		if (!control->reg_4__6)
			goto exit_no_mem;
		control->reg_4__6->address = reg_addr;
		reg_addr += sizeof(control->reg_4__6->data);
	}
	reg_num++;

	/* control 7 */
	if (f54->query.touch_controller_family == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_7 = kzalloc(sizeof(*(control->reg_7)),
				GFP_KERNEL);
		if (!control->reg_7)
			goto exit_no_mem;
		control->reg_7->address = reg_addr;
		reg_addr += sizeof(control->reg_7->data);
	}
	reg_num++;

	/* controls 8 9 */
	if ((f54->query.touch_controller_family == 0) ||
			(f54->query.touch_controller_family == 1)) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_8__9 = kzalloc(sizeof(*(control->reg_8__9)),
				GFP_KERNEL);
		if (!control->reg_8__9)
			goto exit_no_mem;
		control->reg_8__9->address = reg_addr;
		reg_addr += sizeof(control->reg_8__9->data);
	}
	reg_num++;

	/* control 10 */
	if (f54->query.has_interference_metric == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_10 = kzalloc(sizeof(*(control->reg_10)),
				GFP_KERNEL);
		if (!control->reg_10)
			goto exit_no_mem;
		control->reg_10->address = reg_addr;
		reg_addr += sizeof(control->reg_10->data);
	}
	reg_num++;

	/* control 11 */
	if (f54->query.has_ctrl11 == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_11 = kzalloc(sizeof(*(control->reg_11)),
				GFP_KERNEL);
		if (!control->reg_11)
			goto exit_no_mem;
		control->reg_11->address = reg_addr;
		reg_addr += sizeof(control->reg_11->data);
	}
	reg_num++;

	/* controls 12 13 */
	if (f54->query.has_relaxation_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_12__13 = kzalloc(sizeof(*(control->reg_12__13)),
				GFP_KERNEL);
		if (!control->reg_12__13)
			goto exit_no_mem;
		control->reg_12__13->address = reg_addr;
		reg_addr += sizeof(control->reg_12__13->data);
	}
	reg_num++;

	/* controls 14 15 16 */
	if (f54->query.has_sensor_assignment == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;

		control->reg_14 = kzalloc(sizeof(*(control->reg_14)),
				GFP_KERNEL);
		if (!control->reg_14)
			goto exit_no_mem;
		control->reg_14->address = reg_addr;
		reg_addr += sizeof(control->reg_14->data);

		control->reg_15 = kzalloc(sizeof(*(control->reg_15)),
				GFP_KERNEL);
		if (!control->reg_15)
			goto exit_no_mem;
		control->reg_15->length = f54->query.num_of_rx_electrodes;
		control->reg_15->data = kzalloc(control->reg_15->length *
				sizeof(*(control->reg_15->data)), GFP_KERNEL);
		if (!control->reg_15->data)
			goto exit_no_mem;
		control->reg_15->address = reg_addr;
		reg_addr += control->reg_15->length;

		control->reg_16 = kzalloc(sizeof(*(control->reg_16)),
				GFP_KERNEL);
		if (!control->reg_16)
			goto exit_no_mem;
		control->reg_16->length = f54->query.num_of_tx_electrodes;
		control->reg_16->data = kzalloc(control->reg_16->length *
				sizeof(*(control->reg_16->data)), GFP_KERNEL);
		if (!control->reg_16->data)
			goto exit_no_mem;
		control->reg_16->address = reg_addr;
		reg_addr += control->reg_16->length;
	}
	reg_num++;

	/* controls 17 18 19 */
	if (f54->query.has_sense_frequency_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;

		length = num_of_sensing_freqs;

		control->reg_17 = kzalloc(sizeof(*(control->reg_17)),
				GFP_KERNEL);
		if (!control->reg_17)
			goto exit_no_mem;
		control->reg_17->length = length;
		control->reg_17->data = kzalloc(length *
				sizeof(*(control->reg_17->data)), GFP_KERNEL);
		if (!control->reg_17->data)
			goto exit_no_mem;
		control->reg_17->address = reg_addr;
		reg_addr += length;

		control->reg_18 = kzalloc(sizeof(*(control->reg_18)),
				GFP_KERNEL);
		if (!control->reg_18)
			goto exit_no_mem;
		control->reg_18->length = length;
		control->reg_18->data = kzalloc(length *
				sizeof(*(control->reg_18->data)), GFP_KERNEL);
		if (!control->reg_18->data)
			goto exit_no_mem;
		control->reg_18->address = reg_addr;
		reg_addr += length;

		control->reg_19 = kzalloc(sizeof(*(control->reg_19)),
				GFP_KERNEL);
		if (!control->reg_19)
			goto exit_no_mem;
		control->reg_19->length = length;
		control->reg_19->data = kzalloc(length *
				sizeof(*(control->reg_19->data)), GFP_KERNEL);
		if (!control->reg_19->data)
			goto exit_no_mem;
		control->reg_19->address = reg_addr;
		reg_addr += length;
	}
	reg_num++;

	/* control 20 */
	attrs_ctrl_regs_exist[reg_num] = true;
	control->reg_20 = kzalloc(sizeof(*(control->reg_20)),
			GFP_KERNEL);
	if (!control->reg_20)
		goto exit_no_mem;
	control->reg_20->address = reg_addr;
	reg_addr += sizeof(control->reg_20->data);
	reg_num++;

	/* control 21 */
	if (f54->query.has_sense_frequency_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_21 = kzalloc(sizeof(*(control->reg_21)),
				GFP_KERNEL);
		if (!control->reg_21)
			goto exit_no_mem;
		control->reg_21->address = reg_addr;
		reg_addr += sizeof(control->reg_21->data);
	}
	reg_num++;

	/* controls 22 23 24 25 26 */
	if (f54->query.has_firmware_noise_mitigation == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_22__26 = kzalloc(sizeof(*(control->reg_22__26)),
				GFP_KERNEL);
		if (!control->reg_22__26)
			goto exit_no_mem;
		control->reg_22__26->address = reg_addr;
		reg_addr += sizeof(control->reg_22__26->data);
	}
	reg_num++;

	/* control 27 */
	if (f54->query.has_iir_filter == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_27 = kzalloc(sizeof(*(control->reg_27)),
				GFP_KERNEL);
		if (!control->reg_27)
			goto exit_no_mem;
		control->reg_27->address = reg_addr;
		reg_addr += sizeof(control->reg_27->data);
	}
	reg_num++;

	/* control 28 */
	if (f54->query.has_firmware_noise_mitigation == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_28 = kzalloc(sizeof(*(control->reg_28)),
				GFP_KERNEL);
		if (!control->reg_28)
			goto exit_no_mem;
		control->reg_28->address = reg_addr;
		reg_addr += sizeof(control->reg_28->data);
	}
	reg_num++;

	/* control 29 */
	if (f54->query.has_cmn_removal == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_29 = kzalloc(sizeof(*(control->reg_29)),
				GFP_KERNEL);
		if (!control->reg_29)
			goto exit_no_mem;
		control->reg_29->address = reg_addr;
		reg_addr += sizeof(control->reg_29->data);
	}
	reg_num++;

	/* control 30 */
	if (f54->query.has_cmn_maximum == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_30 = kzalloc(sizeof(*(control->reg_30)),
				GFP_KERNEL);
		if (!control->reg_30)
			goto exit_no_mem;
		control->reg_30->address = reg_addr;
		reg_addr += sizeof(control->reg_30->data);
	}
	reg_num++;

	/* control 31 */
	if (f54->query.has_touch_hysteresis == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_31 = kzalloc(sizeof(*(control->reg_31)),
				GFP_KERNEL);
		if (!control->reg_31)
			goto exit_no_mem;
		control->reg_31->address = reg_addr;
		reg_addr += sizeof(control->reg_31->data);
	}
	reg_num++;

	/* controls 32 33 34 35 */
	if (f54->query.has_edge_compensation == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_32__35 = kzalloc(sizeof(*(control->reg_32__35)),
				GFP_KERNEL);
		if (!control->reg_32__35)
			goto exit_no_mem;
		control->reg_32__35->address = reg_addr;
		reg_addr += sizeof(control->reg_32__35->data);
	}
	reg_num++;

	/* control 36 */
	if ((f54->query.curve_compensation_mode == 1) ||
			(f54->query.curve_compensation_mode == 2)) {
		attrs_ctrl_regs_exist[reg_num] = true;

		if (f54->query.curve_compensation_mode == 1) {
			length = max(f54->query.num_of_rx_electrodes,
					f54->query.num_of_tx_electrodes);
		} else if (f54->query.curve_compensation_mode == 2) {
			length = f54->query.num_of_rx_electrodes;
		}

		control->reg_36 = kzalloc(sizeof(*(control->reg_36)),
				GFP_KERNEL);
		if (!control->reg_36)
			goto exit_no_mem;
		control->reg_36->length = length;
		control->reg_36->data = kzalloc(length *
				sizeof(*(control->reg_36->data)), GFP_KERNEL);
		if (!control->reg_36->data)
			goto exit_no_mem;
		control->reg_36->address = reg_addr;
		reg_addr += length;
	}
	reg_num++;

	/* control 37 */
	if (f54->query.curve_compensation_mode == 2) {
		attrs_ctrl_regs_exist[reg_num] = true;

		control->reg_37 = kzalloc(sizeof(*(control->reg_37)),
				GFP_KERNEL);
		if (!control->reg_37)
			goto exit_no_mem;
		control->reg_37->length = f54->query.num_of_tx_electrodes;
		control->reg_37->data = kzalloc(control->reg_37->length *
				sizeof(*(control->reg_37->data)), GFP_KERNEL);
		if (!control->reg_37->data)
			goto exit_no_mem;

		control->reg_37->address = reg_addr;
		reg_addr += control->reg_37->length;
	}
	reg_num++;

	/* controls 38 39 40 */
	if (f54->query.has_per_frequency_noise_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;

		control->reg_38 = kzalloc(sizeof(*(control->reg_38)),
				GFP_KERNEL);
		if (!control->reg_38)
			goto exit_no_mem;
		control->reg_38->length = num_of_sensing_freqs;
		control->reg_38->data = kzalloc(control->reg_38->length *
				sizeof(*(control->reg_38->data)), GFP_KERNEL);
		if (!control->reg_38->data)
			goto exit_no_mem;
		control->reg_38->address = reg_addr;
		reg_addr += control->reg_38->length;

		control->reg_39 = kzalloc(sizeof(*(control->reg_39)),
				GFP_KERNEL);
		if (!control->reg_39)
			goto exit_no_mem;
		control->reg_39->length = num_of_sensing_freqs;
		control->reg_39->data = kzalloc(control->reg_39->length *
				sizeof(*(control->reg_39->data)), GFP_KERNEL);
		if (!control->reg_39->data)
			goto exit_no_mem;
		control->reg_39->address = reg_addr;
		reg_addr += control->reg_39->length;

		control->reg_40 = kzalloc(sizeof(*(control->reg_40)),
				GFP_KERNEL);
		if (!control->reg_40)
			goto exit_no_mem;
		control->reg_40->length = num_of_sensing_freqs;
		control->reg_40->data = kzalloc(control->reg_40->length *
				sizeof(*(control->reg_40->data)), GFP_KERNEL);
		if (!control->reg_40->data)
			goto exit_no_mem;
		control->reg_40->address = reg_addr;
		reg_addr += control->reg_40->length;
	}
	reg_num++;

	/* control 41 */
	if (f54->query.has_signal_clarity == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_41 = kzalloc(sizeof(*(control->reg_41)),
				GFP_KERNEL);
		if (!control->reg_41)
			goto exit_no_mem;
		control->reg_41->address = reg_addr;
		reg_addr += sizeof(control->reg_41->data);
	}
	reg_num++;

	/* control 42 */
	if (f54->query.has_variance_metric == 1)
		reg_addr += CONTROL_42_SIZE;

	/* controls 43 44 45 46 47 48 49 50 51 52 53 54 */
	if (f54->query.has_multi_metric_state_machine == 1)
		reg_addr += CONTROL_43_54_SIZE;

	/* controls 55 56 */
	if (f54->query.has_0d_relaxation_control == 1)
		reg_addr += CONTROL_55_56_SIZE;

	/* control 57 */
	if (f54->query.has_0d_acquisition_control == 1) {
		attrs_ctrl_regs_exist[reg_num] = true;
		control->reg_57 = kzalloc(sizeof(*(control->reg_57)),
				GFP_KERNEL);
		if (!control->reg_57)
			goto exit_no_mem;
		control->reg_57->address = reg_addr;
		reg_addr += sizeof(control->reg_57->data);
	}
	reg_num++;

	/* control 58 */
	if (f54->query.has_0d_acquisition_control == 1)
		reg_addr += CONTROL_58_SIZE;

	/* control 59 */
	if (f54->query.has_h_blank == 1)
		reg_addr += CONTROL_59_SIZE;

	/* controls 60 61 62 */
	if ((f54->query.has_h_blank == 1) ||
			(f54->query.has_v_blank == 1) ||
			(f54->query.has_long_h_blank == 1))
		reg_addr += CONTROL_60_62_SIZE;

	/* control 63 */
	if ((f54->query.has_h_blank == 1) ||
			(f54->query.has_v_blank == 1) ||
			(f54->query.has_long_h_blank == 1) ||
			(f54->query.has_slew_metric == 1) ||
			(f54->query.has_slew_option == 1) ||
			(f54->query.has_noise_mitigation2 == 1))
		reg_addr += CONTROL_63_SIZE;

	/* controls 64 65 66 67 */
	if (f54->query.has_h_blank == 1)
		reg_addr += CONTROL_64_67_SIZE * 7;
	else if ((f54->query.has_v_blank == 1) ||
			(f54->query.has_long_h_blank == 1))
		reg_addr += CONTROL_64_67_SIZE;

	/* controls 68 69 70 71 72 73 */
	if ((f54->query.has_h_blank == 1) ||
			(f54->query.has_v_blank == 1) ||
			(f54->query.has_long_h_blank == 1))
		reg_addr += CONTROL_68_73_SIZE;

	/* control 74 */
	if (f54->query.has_slew_metric == 1)
		reg_addr += CONTROL_74_SIZE;

	/* control 75 */
	if (f54->query.has_enhanced_stretch == 1)
		reg_addr += num_of_sensing_freqs;

	/* control 76 */
	if (f54->query.has_startup_fast_relaxation == 1)
		reg_addr += CONTROL_76_SIZE;

	/* controls 77 78 */
	if (f54->query.has_esd_control == 1)
		reg_addr += CONTROL_77_78_SIZE;

	/* controls 79 80 81 82 83 */
	if (f54->query.has_noise_mitigation2 == 1)
		reg_addr += CONTROL_79_83_SIZE;

	/* controls 84 85 */
	if (f54->query.has_energy_ratio_relaxation == 1)
		reg_addr += CONTROL_84_85_SIZE;

	/* control 86 */
	if ((f54->query.has_query13 == 1) && (f54->query.has_ctrl86 == 1))
		reg_addr += CONTROL_86_SIZE;

	/* control 87 */
	if ((f54->query.has_query13 == 1) && (f54->query.has_ctrl87 == 1))
		reg_addr += CONTROL_87_SIZE;

	/* control 88 */
	if (f54->query.has_ctrl88 == 1) {
		control->reg_88 = kzalloc(sizeof(*(control->reg_88)),
				GFP_KERNEL);
		if (!control->reg_88)
			goto exit_no_mem;
		control->reg_88->address = reg_addr;
		//warn repprted in hisi fortify_report check,delete it
		//reg_addr += sizeof(control->reg_88->data);
	}

	return 0;

exit_no_mem:
	TS_LOG_ERR("%s: Failed to alloc mem for control registers\n",__func__);
	return -ENOMEM;
}


static int synaptics_rmi4_f54_status_work(struct work_struct *work)
{
	int retval;
	unsigned char report_index[2];
	struct synaptics_rmi4_data *rmi4_data = f54->rmi4_data;
	int i = 0;
	unsigned int report_times_max = 0;
	unsigned int report_size_temp = MAX_I2C_MSG_LENS;
	unsigned char *report_data_temp = NULL;
	if (f54->status != STATUS_BUSY)
		return;

	set_report_size();
	if (f54->report_size == 0) {
		TS_LOG_ERR("%s: Report data size = 0\n",__func__);
		retval = -EINVAL;
		goto error_exit;
	}

	if (f54->data_buffer_size < f54->report_size) {
		mutex_lock(&f54->data_mutex);
		if (f54->data_buffer_size)
			kfree(f54->report_data);
		f54->report_data = kzalloc(f54->report_size, GFP_KERNEL);
		if (!f54->report_data) {
			TS_LOG_ERR("%s: Failed to alloc mem for data buffer\n",__func__);
			f54->data_buffer_size = 0;
			mutex_unlock(&f54->data_mutex);
			retval = -ENOMEM;
			goto error_exit;
		}
		f54->data_buffer_size = f54->report_size;
		mutex_unlock(&f54->data_mutex);
	}
	report_times_max = f54->report_size/MAX_I2C_MSG_LENS;
	if(f54->report_size%MAX_I2C_MSG_LENS != 0)
	{
		report_times_max += 1;
	}
	report_index[0] = 0;
	report_index[1] = 0;

	retval = f54->fn_ptr->write(rmi4_data,
			f54->data_base_addr + DATA_REPORT_INDEX_OFFSET,
			report_index,
			sizeof(report_index));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to write report data index\n",__func__);
		retval = -EINVAL;
		goto error_exit;
	}
	mutex_lock(&f54->data_mutex);
	/* Point to the block data about to transfer */
	report_data_temp = f54->report_data;
	for(i = 0;i < report_times_max;i ++)
	{

		if(i == (report_times_max - 1))
		{
			/* The last time transfer the rest of the block data */
			report_size_temp = f54->report_size%MAX_I2C_MSG_LENS;
		}
		retval = f54->fn_ptr->read(rmi4_data,
				f54->data_base_addr + DATA_REPORT_DATA_OFFSET,
				report_data_temp,
				report_size_temp);
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to read report data\n",__func__);
			retval = -EINVAL;
			mutex_unlock(&f54->data_mutex);
			goto error_exit;
		}
		/* Point to the next 256bytes data */
		report_data_temp += MAX_I2C_MSG_LENS;
	}
	mutex_unlock(&f54->data_mutex);
	retval = STATUS_IDLE;

#ifdef RAW_HEX
	print_raw_hex_report();
#endif

#ifdef HUMAN_READABLE
	print_image_report();
#endif

error_exit:
	mutex_lock(&f54->status_mutex);
	f54->status = retval;
	mutex_unlock(&f54->status_mutex);

	return retval;
}

static int synaptics_rmi4_f54_attention(void)
{
	 return synaptics_rmi4_f54_status_work(NULL);
}

static void synaptics_rmi4_f54_set_regs(struct synaptics_rmi4_data *rmi4_data,
		struct synaptics_rmi4_fn_desc *fd,
		unsigned int intr_count,
		unsigned char page)
{
	unsigned char ii;
	unsigned char intr_offset;

	f54->query_base_addr = fd->query_base_addr | (page << 8);
	f54->control_base_addr = fd->ctrl_base_addr | (page << 8);
	f54->data_base_addr = fd->data_base_addr | (page << 8);
	f54->command_base_addr = fd->cmd_base_addr | (page << 8);

	f54->intr_reg_num = (intr_count + 7) / 8;
	if (f54->intr_reg_num != 0)
		f54->intr_reg_num -= 1;

	f54->intr_mask = 0;
	intr_offset = intr_count % 8;
	for (ii = intr_offset;
			ii < ((fd->intr_src_count & MASK_3BIT) +
			intr_offset);
			ii++) {
		f54->intr_mask |= 1 << ii;
	}

	return;
}

static void synaptics_rmi5_f55_init(struct synaptics_rmi4_data *rmi4_data)
{
	int retval;
	unsigned char ii;
	unsigned char rx_electrodes = f54->query.num_of_rx_electrodes;
	unsigned char tx_electrodes = f54->query.num_of_tx_electrodes;

	retval = f54->fn_ptr->read(rmi4_data,
			f55->query_base_addr,
			f55->query.data,
			sizeof(f55->query.data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f55 query registers\n",__func__);
		return;
	}

	if (!f55->query.has_sensor_assignment)
		return;

	f55->rx_assignment = kzalloc(rx_electrodes, GFP_KERNEL);
	f55->tx_assignment = kzalloc(tx_electrodes, GFP_KERNEL);

	retval = f54->fn_ptr->read(rmi4_data,
			f55->control_base_addr + SENSOR_RX_MAPPING_OFFSET,
			f55->rx_assignment,
			rx_electrodes);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f55 rx assignment\n",__func__);
		return;
	}

	retval = f54->fn_ptr->read(rmi4_data,
			f55->control_base_addr + SENSOR_TX_MAPPING_OFFSET,
			f55->tx_assignment,
			tx_electrodes);
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f55 tx assignment\n",__func__);
		return;
	}

	f54->rx_assigned = 0;
	for (ii = 0; ii < rx_electrodes; ii++) {
		if (f55->rx_assignment[ii] != 0xff)
			f54->rx_assigned++;
	}

	f54->tx_assigned = 0;
	for (ii = 0; ii < tx_electrodes; ii++) {
		if (f55->tx_assignment[ii] != 0xff)
			f54->tx_assigned++;
	}

	return;
}

static void synaptics_rmi4_f55_set_regs(struct synaptics_rmi4_data *rmi4_data,
		struct synaptics_rmi4_fn_desc *fd,
		unsigned char page)
{
	f55 = kzalloc(sizeof(*f55), GFP_KERNEL);
	if (!f55) {
		TS_LOG_ERR("%s: Failed to alloc mem for f55\n",__func__);
		return;
	}

	f55->query_base_addr = fd->query_base_addr | (page << 8);
	f55->control_base_addr = fd->ctrl_base_addr | (page << 8);
	f55->data_base_addr = fd->data_base_addr | (page << 8);
	f55->command_base_addr = fd->cmd_base_addr | (page << 8);

	return;
}

static int match_module_name(const char* module_name)
{
	TS_LOG_INFO("%s: module_name = %s\n", __func__, module_name);

	if (strcmp(module_name, "oflim") == 0) //oflim
	{
		if(!strcmp(g_ts_data.product_name,"g760s")) {
			FullRawMaxCap = FullRawMaxCap_oflim_g760s;
			FullRawMinCap = FullRawMinCap_oflim_g760s;

			FullRawCapUpperLimit = FullRawCapUpperLimit_oflim_g760s;
			FullRawCapLowerLimit = FullRawCapLowerLimit_oflim_g760s;

			HighResistanceUpperLimit = HighResistanceUpperLimit_oflim_g760s;
			HighResistanceLowerLimit = HighResistanceLowerLimit_oflim_g760s;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_oflim_g760s;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_oflim_g760s;

		} else {
			FullRawMaxCap = FullRawMaxCap_oflim;
			FullRawMinCap = FullRawMinCap_oflim;

			FullRawCapUpperLimit = FullRawCapUpperLimit_oflim;
			FullRawCapLowerLimit = FullRawCapLowerLimit_oflim;

			HighResistanceUpperLimit = HighResistanceUpperLimit_oflim;
			HighResistanceLowerLimit = HighResistanceLowerLimit_oflim;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_oflim;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_oflim;
		}
		return 0;

	}
	else if (strcmp(module_name, "lensone") == 0) //lensone
	{
		if(!strcmp(g_ts_data.product_name,"g760s")) {
			FullRawMaxCap = FullRawMaxCap_lensone_g760s;
			FullRawMinCap = FullRawMinCap_lensone_g760s;

			FullRawCapUpperLimit = FullRawCapUpperLimit_lensone_760s;
			FullRawCapLowerLimit = FullRawCapLowerLimit_lensone_g760s;

			HighResistanceUpperLimit = HighResistanceUpperLimit_lensone_g760s;
			HighResistanceLowerLimit = HighResistanceLowerLimit_lensone_g760s;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_lensone_g760s;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_lensone_g760s;

		} else {
			FullRawMaxCap = FullRawMaxCap_lensone;
			FullRawMinCap = FullRawMinCap_lensone;

			FullRawCapUpperLimit = FullRawCapUpperLimit_lensone;
			FullRawCapLowerLimit = FullRawCapLowerLimit_lensone;

			HighResistanceUpperLimit = HighResistanceUpperLimit_lensone;
			HighResistanceLowerLimit = HighResistanceLowerLimit_lensone;

			RxDiagonalUpperLimit = RxDiagonalUpperLimit_lensone;
			RxDiagonalLowerLimit = RxDiagonalLowerLimit_lensone;
		}
		return 0;

	}
	else if (strcmp(module_name, "GIS") == 0) //GIS
	{
		FullRawMaxCap = FullRawMaxCap_GIS;
		FullRawMinCap = FullRawMinCap_GIS;

		FullRawCapUpperLimit = FullRawCapUpperLimit_GIS;
		FullRawCapLowerLimit = FullRawCapLowerLimit_GIS;

		HighResistanceUpperLimit = HighResistanceUpperLimit_GIS;
		HighResistanceLowerLimit = HighResistanceLowerLimit_GIS;

		RxDiagonalUpperLimit = RxDiagonalUpperLimit_GIS;
		RxDiagonalLowerLimit = RxDiagonalLowerLimit_GIS;

		return 0;

	}
	else if (strcmp(module_name, "YASSY") == 0) //YASSY
	{
		FullRawMaxCap = FullRawMaxCap_YASSY;
		FullRawMinCap = FullRawMinCap_YASSY;

		FullRawCapUpperLimit = FullRawCapUpperLimit_YASSY;
		FullRawCapLowerLimit = FullRawCapLowerLimit_YASSY;

		HighResistanceUpperLimit = HighResistanceUpperLimit_YASSY;
		HighResistanceLowerLimit = HighResistanceLowerLimit_YASSY;

		RxDiagonalUpperLimit = RxDiagonalUpperLimit_YASSY;
		RxDiagonalLowerLimit = RxDiagonalLowerLimit_YASSY;

		return 0;

	}
	else
	{
		TS_LOG_ERR("%s: Failed to match module_name \n", __func__);
		return -1;
	}

}

 int synaptics_rmi4_f54_s3207_init(struct synaptics_rmi4_data *rmi4_data,const char *module_name)
{
	int retval;
	unsigned short ii;
	unsigned char page;
	unsigned char intr_count = 0;
	bool f54found = false;
	bool f55found = false;
	struct synaptics_rmi4_fn_desc rmi_fd;
	TS_LOG_INFO("%s: enter\n",__func__);

      retval = match_module_name(module_name);
	if( retval < 0 ){
		retval = -ENOMEM;
		goto exit;
	}

	f54 = kzalloc(sizeof(*f54), GFP_KERNEL);
	if (!f54) {
		TS_LOG_ERR("%s: Failed to alloc mem for f54\n",__func__);
		retval = -ENOMEM;
		goto exit;
	}

	f54->fn_ptr = kzalloc(sizeof(*(f54->fn_ptr)), GFP_KERNEL);
	if (!f54->fn_ptr) {
		TS_LOG_ERR("%s: Failed to alloc mem for fn_ptr\n",__func__);
		retval = -ENOMEM;
		goto exit_free_f54;
	}

	f54->rmi4_data = rmi4_data;
	f54->fn_ptr->read = rmi4_data->i2c_read;
	f54->fn_ptr->write = rmi4_data->i2c_write;
	f54->fn_ptr->enable = rmi4_data->irq_enable;

	for (page = 0; page < PAGES_TO_SERVICE; page++) {
		for (ii = PDT_START; ii > PDT_END; ii -= PDT_ENTRY_SIZE) {
			ii |= (page << 8);

			retval = f54->fn_ptr->read(rmi4_data,
					ii,
					(unsigned char *)&rmi_fd,
					sizeof(rmi_fd));
			if (retval < 0)
				goto exit_free_mem;

			if (!rmi_fd.fn_number)
				break;

			switch (rmi_fd.fn_number) {
			case SYNAPTICS_RMI4_F54:
				synaptics_rmi4_f54_set_regs(rmi4_data,
						&rmi_fd, intr_count, page);
				f54found = true;
				break;
			case SYNAPTICS_RMI4_F55:
				synaptics_rmi4_f55_set_regs(rmi4_data,
						&rmi_fd, page);
				f55found = true;
				break;
			default:
				break;
			}

			if (f54found && f55found)
				goto pdt_done;

			intr_count += (rmi_fd.intr_src_count & MASK_3BIT);
		}
	}

	if (!f54found) {
		TS_LOG_INFO("%s: line(%d)\n", __func__,__LINE__);
		retval = -ENODEV;
		goto exit_free_mem;
	}

pdt_done:
	retval = f54->fn_ptr->read(rmi4_data,
			f54->query_base_addr,
			f54->query.data,
			sizeof(f54->query.data));
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to read f54 query registers\n",__func__);
		goto exit_free_mem;
	}

	f54->rx_assigned = f54->query.num_of_rx_electrodes;
	f54->tx_assigned = f54->query.num_of_tx_electrodes;

	retval = synaptics_rmi4_f54_set_ctrl();
	if (retval < 0) {
		TS_LOG_ERR("%s: Failed to set up f54 control registers\n",__func__);
		goto exit_free_control;
	}

	if (f55found)
		synaptics_rmi5_f55_init(rmi4_data);

	mutex_init(&f54->status_mutex);
	mutex_init(&f54->data_mutex);
	mutex_init(&f54->control_mutex);
/*Add synaptics capacitor test function */
#if 1
	TS_LOG_INFO("%s: sysfs_is_busy = %d\n", __func__,sysfs_is_busy);
	if (!sysfs_is_busy) {
		retval = synaptics_rmi4_f54_set_sysfs();
		if (retval < 0) {
			TS_LOG_ERR("%s: Failed to create sysfs entries\n",__func__);
			goto exit_sysfs;
		}
		sysfs_is_busy = false;
	}
#endif
	f54->status_workqueue =
			create_singlethread_workqueue("f54_status_workqueue");
	INIT_DELAYED_WORK(&f54->status_work,
			synaptics_rmi4_f54_status_work);

#ifdef WATCHDOG_HRTIMER
	/* Watchdog timer to catch unanswered get report commands */
	hrtimer_init(&f54->watchdog, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
	f54->watchdog.function = get_report_timeout;

	/* Work function to do actual cleaning up */
	INIT_WORK(&f54->timeout_work, timeout_set_status);
#endif

	f54->status = STATUS_IDLE;

	return 0;

exit_sysfs:
	kfree(f55->rx_assignment);
	kfree(f55->tx_assignment);

exit_free_control:
	free_control_mem();

exit_free_mem:
	kfree(f55);
	kfree(f54->fn_ptr);

exit_free_f54:
	kfree(f54);
	f54 = NULL;

exit:
	return retval;
}
#if 0
static void synaptics_rmi4_f54_remove(struct synaptics_rmi4_data *rmi4_data)
{
	if (!f54)
		goto exit;

#ifdef WATCHDOG_HRTIMER
	hrtimer_cancel(&f54->watchdog);
#endif

	cancel_delayed_work_sync(&f54->status_work);
	flush_workqueue(f54->status_workqueue);
	destroy_workqueue(f54->status_workqueue);

/*Add synaptics capacitor test function */
	if (!sysfs_is_busy)
		remove_sysfs();

	kfree(f55->rx_assignment);
	kfree(f55->tx_assignment);

	free_control_mem();

	kfree(f55);

	if (f54->data_buffer_size)
		kfree(f54->report_data);

	kfree(f54->fn_ptr);
	kfree(f54);
	f54 = NULL;

/*move free action to module_exit,because the cap test
 is complexity,I change this to other place,but panic always
 happened,so move to module exit for safety*/
exit:
	complete(&f54_remove_complete);

	return;
}
#endif
