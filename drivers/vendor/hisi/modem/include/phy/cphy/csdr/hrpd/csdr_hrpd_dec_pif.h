/** ****************************************************************************

                    Huawei Technologies Sweden AB (C), 2001-2016

 ********************************************************************************
 * @author    Automatically generated by DAISY
 * @version
 * @date      2016-01-03 15:07:31
 * @file
 * @brief
 * This interface carries forward link data to CTTF_HRPD on dedicate state.
 *
 * This includes forward link data, type of data and size of data. The decoded
 * data and related parameters are communicated to CTTF_HRPD via a shared buffer
 * of type CSDR_HRPD_FWD_DATA_BUF_INFO_STRU. A visual representation of the
 * buffer is outlined in  below.
 *
 * In addition to the data communicated in the HRPD FWD Buffer, decoded MAC
 * Channel, P_ARQ and parameters used for rate adaptation are communicated in a
 * shared buffer of type CSDR_HRPD_SLOT_BUF_STRU to CTTF_HRPD.
 *
 * ATTENTION:
 * Because SDR puts CSDR_HRPD_ADDR_INFO_STRU, @ulFCtrlMgmtAddr, @ulRCtrlMgmtAddr
 * and @ulSlotMgmtAddr in TCM of BBE16. To avoid MAC read SDR's TCM after SDR
 * has been power-down, do not put anything in common state into share-memory.
 * @copyright Huawei Technologies Sweden AB
 *******************************************************************************/
#ifndef CSDR_HRPD_DEC_PIF_H
#define CSDR_HRPD_DEC_PIF_H

/*******************************************************************************
 1. Other files included
*******************************************************************************/

#include "vos.h"

#ifdef __cplusplus
#if __cplusplus
    extern "C" {
#endif /* __cpluscplus */
#endif /* __cpluscplus */
#pragma pack(4)

/*******************************************************************************
 2. Macro definitions
*******************************************************************************/

/**
 * define the max size of data container that CSDR sent to FMAC whent CSDR have
 * received a CCMAC/eCCMAC Packet successfully. unit is 16bits
 */
#define CSDR_HRPD_CC_PACKET_MAX_SIZE                        ( 64 )
/**
 * As MAC every 4 slots trigger by interrupt, then at least 5 blocks needs to
 * store in buffer, because we use head and tail index mechanism. And we worry
 * about that when MAC is reading data, CSDR is going to write a new data. So
 * we give one more, then totally 6 blocks.
 */
#define CSDR_HRPD_DECODER_NUM_FWD_BUF_INSTANCES             ( 6 )
/**
 * The maximum (Physical Layer Packet Size(bits) in Transmission Format is
 * 5120, from Table 13.3.1.3.1.1-1. Modulation Parameters for the Forward
 * Traffic Channel and the Control Channel, 3GPP2 C.S0024-A v3.0: "cdma2000
 * High Rate Packet Data Air Interface Specification"
 * 5120 bits = 160 * 32bits(a word = 4 octets)
 */
#define CSDR_HRPD_MAX_NUM_DECODED_32BIT_WORDS               ( 160 )

/*******************************************************************************
 3. Enumerations declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CSDR_HRPD_DEC_PIF_MSG_TYPE_ENUM_UINT16
 *
 * Description :
 *******************************************************************************/
enum CSDR_HRPD_DEC_PIF_MSG_TYPE_ENUM
{
    ID_CSDR_CTTF_HRPD_CC_DATA_IND                           = 0x4800, /**< @sa CSDR_CTTF_HRPD_CC_DATA_IND_STRU */
    ID_CSDR_CTTF_HRPD_DDR_RAM_BASE_ADDR_IND                 = 0x4801, /**< @sa CSDR_CTTF_HRPD_DDR_RAM_BASE_ADDR_IND_STRU */
    ID_CSDR_HRPD_DEC_PIF_MSG_TYPE_ENUM_BUTT                 = 0x4802
};
typedef VOS_UINT16 CSDR_HRPD_DEC_PIF_MSG_TYPE_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CSDR_HRPD_DECODED_PACKET_SIZE_TYPE_ENUM_UINT16
 *
 * Description : This enum defines the set of possible sizes for the decoded
 * MAC layer packets. The sizes are valid for default FTC, enhanced FTC,
 * default CC and enhanced CC.
 *******************************************************************************/
enum CSDR_HRPD_DECODED_PACKET_SIZE_TYPE_ENUM
{
    CSDR_HRPD_DECODED_PACKET_SIZE_98_TYPE                   = 0x0000,
    CSDR_HRPD_DECODED_PACKET_SIZE_226_TYPE                  = 0x0001,
    CSDR_HRPD_DECODED_PACKET_SIZE_482_TYPE                  = 0x0002,
    CSDR_HRPD_DECODED_PACKET_SIZE_994_TYPE                  = 0x0003,
    CSDR_HRPD_DECODED_PACKET_SIZE_1002_TYPE                 = 0x0004,
    CSDR_HRPD_DECODED_PACKET_SIZE_2018_TYPE                 = 0x0005,
    CSDR_HRPD_DECODED_PACKET_SIZE_2026_TYPE                 = 0x0006,
    CSDR_HRPD_DECODED_PACKET_SIZE_3042_TYPE                 = 0x0007,
    CSDR_HRPD_DECODED_PACKET_SIZE_3050_TYPE                 = 0x0008,
    CSDR_HRPD_DECODED_PACKET_SIZE_4066_TYPE                 = 0x0009,
    CSDR_HRPD_DECODED_PACKET_SIZE_4074_TYPE                 = 0x000A,
    CSDR_HRPD_DECODED_PACKET_SIZE_5090_TYPE                 = 0x000B,
    CSDR_HRPD_DECODED_PACKET_SIZE_TYPE_BUTT                 = 0x000C
};
typedef VOS_UINT16 CSDR_HRPD_DECODED_PACKET_SIZE_TYPE_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CSDR_HRPD_CHANNEL_TYPE_ENUM_UINT16
 *
 * Description : This enumeration defines the set of possible decoding types.
 *******************************************************************************/
enum CSDR_HRPD_CHANNEL_TYPE_ENUM
{
    CSDR_HRPD_PACKET_CHANNEL_TYPE_CC                        = 0x0000, /**< Packet is a  Control Channel packet */
    CSDR_HRPD_PACKET_CHANNEL_TYPE_FTC_SU                    = 0x0001, /**< Packet is a Single User FTC packet */
    CSDR_HRPD_PACKET_CHANNEL_TYPE_FTC_MU                    = 0x0002, /**< Packet is a MultiUser FTC packet with at least one Security layer packet for
AT. */
    CSDR_HRPD_PACKET_CHANNEL_TYPE_BUTT                      = 0x0003
};
typedef VOS_UINT16 CSDR_HRPD_CHANNEL_TYPE_ENUM_UINT16;

/*******************************************************************************
 4. Message Header declaration
*******************************************************************************/

/*******************************************************************************
 5. Message declaration
*******************************************************************************/

/*******************************************************************************
 6. STRUCT and UNION declaration
*******************************************************************************/

/** ****************************************************************************
 * Name        : CSDR_HRPD_FWD_DATA_BUF_CTRL_STRU
 *
 * Description : This struct defines the buffer control parameters for the FWD
 * data buffer, which is shared between CSDR_HRPD and CTTF_HRPD.
 *
 * Upon decoding success and after the fields of the
 * CSDR_HRPD_FWD_DATA_BUF_INFO_STRU are updated, CSDR_HRPD increments the
 * headIndex parameter. CTTF_HRPD will read the headIndex parameter to check if
 * new data is present. If headIndex > tailIndex, then new data is present in
 * the buffer. When CTTF_HRPD  is finished processing the buffer, the tailIndex
 * is incremented.
 * In case no buffer is free, a buffer overflow indication shall be sent to
 * CTTF_HRPD via CPHYPROC.
 * And CSDR_HRPD will only put decode data into data buffer and increase head
 * index one, if decode data crc is correct.
 *
 * They are initialed by CSDR to zero.
 * If head index == tail index, it means empty; if head index + 1 mod
 * CSDR_HRPD_DECODER_NUM_FWD_BUF_INSTANCES == tail index, it means full.
 * When buffer is full, SDR drops new decoded data. Otherwise, SDR puts data
 * into the place of head index, then plus one to head index.
 * After MAC read out data from the place of tail index, then plus one to tail
 * index.
 *
 * When CSDR receives release request when it's doing decoding, CSDR needs to
 * wait until finished decoding, then do release operation. And the last
 * decoded data needs to write into data buffer and move head index as usually.
 * However, MAC may drop it after received CPROC_CTTF_HRPD_TCH_RELEASE_CNF, as
 * MAC may drop the data waiting for itself to read out.
 *
 * If CSDR receives release-all request, after done release operation, CSDR
 * needs to force to make tail and head point to the same position.
 *******************************************************************************/
typedef struct
{
    VOS_UINT32                          ulHeadIndex; /**< [0...CSDR_HRPD_DECODER_NUM_FWD_BUF_INSTANCES-1] */
    VOS_UINT32                          ulTailIndex; /**< [0...CSDR_HRPD_DECODER_NUM_FWD_BUF_INSTANCES-1] */
} CSDR_HRPD_FWD_DATA_BUF_CTRL_STRU;

/** ****************************************************************************
 * Name        : CSDR_HRPD_FWD_DATA_BUF_DATA_PARA_STRU
 *
 * Description : It's parameters for corresponding data. The index of parameter
 * and data in data buffer should be the same.
 * CSDR needs to initial @ulFwdDataBufferStartAddr to corresponding data
 * address(&aulDecodedPacketData[index][0]) when CSDR_HRPD is setup. After
 * neither CSDR nor MAC will change its value.
 *
 * @usRunningNum: It's like swift number or running number in bank. After power
 * on, for the 1st message, it's 0, then the next message, it's 1, and so on.
 * It'll be helpful to decide which one comes first while both received
 * cc_data_ind signal and cc data in forward data buffer in latest 4 slots on
 * dedicate state.
 *
 * @usCfgId: It's a TCH config or reconfig id. When MAC config or reconfig TCH,
 * it will create a ulCfgId indicating a group of TCH parameters and send to
 * PHY. After CSDR using the TCH parameters to decoding, it will echo the
 * ulCfgId back MAC.
 *
 * @usFwdPhysSlots: The number of slots over which the Physical Layer packet
 * containing the current PL_0_1_2 FETAP Test Packet was received.on the
 * Forward Traffic Channel
 *******************************************************************************/
typedef struct
{
    CSDR_HRPD_CHANNEL_TYPE_ENUM_UINT16                      enChannelType;            /**< DCC, ECC, FTC Single User, FTC Multi User */
    VOS_UINT16                                              usSubProtocol;            /**< 0: default physical layer protocol type, 1: subtype1, 2:subtype2 */
    CSDR_HRPD_DECODED_PACKET_SIZE_TYPE_ENUM_UINT16          enMacPacketSizeType;
    VOS_UINT16                                              usScPnIndex;              /**< current SC PN index */
    VOS_UINT16                                              usRunningNum;             /**< only for cc channel data */
    VOS_UINT16                                              ausReserved[1];
    VOS_UINT32                                              ulFwdDataBufferStartAddr; /**< always point to current index's address of aulDecodedPacketData[index][0] */
    VOS_UINT16                                              usCfgId;                  /**< only for FTC channel data */
    VOS_UINT16                                              usFwdPhysSlots;           /**< The number of slots over which the Physical Layer packet containing the current PL_0_1_2 FETAP Test Packet was received.on the Forward Traffic Channel */
    VOS_UINT16                                              usMaxSubPacketNum;        /**< the data packet max sub packet  1-16 */
    VOS_UINT16                                              usCurrentSubPacketNum;    /**< the data packet current sub packet number when CRC OK 0-15 */
    VOS_UINT16                                              usPreambleSlotIdx;        /**< the system slot idx when preamble is  detected in 5.12s,0----3071 */
    VOS_UINT16                                              usReserved;
} CSDR_HRPD_FWD_DATA_BUF_DATA_PARA_STRU;

/** ****************************************************************************
 * Name        : CSDR_HRPD_FWD_DATA_BUF_DATA_STRU
 *
 * Description : This structure defines the buffer data in the shared decoding
 * buffer. It's used with corresponding parameters. The index of data array and
 * parameter array should be the same.
 *******************************************************************************/
typedef struct
{
    VOS_UINT32                          aulDecodedPacketData[CSDR_HRPD_DECODER_NUM_FWD_BUF_INSTANCES][CSDR_HRPD_MAX_NUM_DECODED_32BIT_WORDS];
} CSDR_HRPD_FWD_DATA_BUF_DATA_STRU;

/** ****************************************************************************
 * Name        : CSDR_HRPD_FWD_DATA_BUF_INFO_STRU
 *
 * Description : The types defined below are used to communicate decoded
 * Control Channel / Forward Traffic Channel / Enhanced Forward Traffic Channel
 * data to CTTF_HRPD.
 *
 * Data parameter and data make pair. The index of parameter array and data
 * array(data buffer) should be the same.
 *******************************************************************************/
typedef struct
{
    CSDR_HRPD_FWD_DATA_BUF_DATA_PARA_STRU                   astFwdDataBuffer[CSDR_HRPD_DECODER_NUM_FWD_BUF_INSTANCES];
} CSDR_HRPD_FWD_DATA_BUF_INFO_STRU;

/*******************************************************************************
 7. OTHER declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CSDR_CTTF_HRPD_CC_DATA_IND_STRU
 *
 * Description : This signal is sent from CSDR to CTTF_HRPD_FMAC when CSDR has
 * received a CCMAC/eCCMAC Packet successfully.
 *
 * @usRunningNum: It's like swift number or running number in bank. After power
 * on, for the 1st message, it's 0, then the next message, it's 1, and so on.
 * It'll be helpful to decide which one comes first while both received
 * cc_data_ind signal and cc data in forward data buffer in latest 4 slots on
 * dedicate state.
 *
 * @usSubProtocol: ECC is only for subtype 2 physical layer protocol.
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_HRPD_DEC_PIF_MSG_TYPE_ENUM_UINT16                  enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT16                                              usCCcycleStartPos;                     /**< the beginning of the cccycle in half-slot */
    VOS_UINT16                                              usOffset;                              /**< the first SC packet position relative to the beginning of the cccycle */
    VOS_UINT16                                              usNumBit;                              /**< Data size in bit */
    VOS_UINT16                                              usRunningNum;
    VOS_UINT16                                              usSubProtocol;                         /**< 0: default physical layer protocol type, 1: subtype1, 2:subtype2 */
    VOS_UINT16                                              ausReserved[1];
    VOS_UINT16                                              ausData[CSDR_HRPD_CC_PACKET_MAX_SIZE]; /**< data container */
} CSDR_CTTF_HRPD_CC_DATA_IND_STRU;

/** ****************************************************************************
 * Name        : CSDR_CTTF_HRPD_DDR_RAM_BASE_ADDR_IND_STRU
 *
 * Description : This signal is sent from CSDR to CTTF_HRPD_FMAC when CSDR has
 * got the "ddr_ram_base address".
 * ddr_ram_base address:
 * This address is used to require share-memory address between SDR and MAC in
 * HRPD. To read it, user can know where to inquire the address of
 * CSDR_HRPD_ADDR_INFO_STRU. The start address of stored into ulDdrRamBaseAddr.
 * So MAC first read the address stored in ulDdrRamBaseAddr, then jump to
 * CSDR_HRPD_ADDR_INFO_STRU.
 *
 * if CSDR send this msg to MAC more than one time, CSDR will make sure the
 * value of ulDdrRamBaseAddr is same.
 * When MAC recieve the msg with value of ulDdrRamBaseAddr were not the same as
 * the last time, MAC will throw error and ignore the msg.
 *
 * @ulDdrRamBaseAddr: The value stored in ulDdrRamBaseAddr is the address of
 * CSDR_HRPD_ADDR_INFO_STRU
 *******************************************************************************/
typedef struct
{
    VOS_MSG_HEADER
    CSDR_HRPD_DEC_PIF_MSG_TYPE_ENUM_UINT16                  enMsgId;
    VOS_UINT16                                              usOpId;
    VOS_UINT32                                              ulDdrRamBaseAddr; /**< ddr ram base address for HRPD */
} CSDR_CTTF_HRPD_DDR_RAM_BASE_ADDR_IND_STRU;

/*******************************************************************************
 8. Global  declaration
*******************************************************************************/

/*******************************************************************************
 9. Function declarations
*******************************************************************************/

#if ((VOS_OS_VER == VOS_WIN32) || (VOS_OS_VER == VOS_NUCLEUS))
#pragma pack()
#else
#pragma pack(0)
#endif

#ifdef __cplusplus
#if __cplusplus
}
#endif /* __cpluscplus */
#endif /* __cpluscplus */

#endif
