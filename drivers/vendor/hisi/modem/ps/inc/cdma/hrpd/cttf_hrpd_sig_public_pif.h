/** ****************************************************************************

                    Huawei Technologies Sweden AB (C), 2001-2016

 ********************************************************************************
 * @author    Automatically generated by DAISY
 * @version
 * @date      2016-01-05 11:00:25
 * @file
 * @brief
 * @copyright Huawei Technologies Sweden AB
 *******************************************************************************/
#ifndef CTTF_HRPD_SIG_PUBLIC_PIF_H
#define CTTF_HRPD_SIG_PUBLIC_PIF_H

/*******************************************************************************
 1. Other files included
*******************************************************************************/

#include "vos.h"
#include "PsTypeDef.h"
#include "TtfDrvInterface.h"

#ifdef __cplusplus
#if __cplusplus
    extern "C" {
#endif /* __cpluscplus */
#endif /* __cpluscplus */
#pragma pack(4)

/*******************************************************************************
 2. Macro definitions
*******************************************************************************/

/**
 * the maximum valid protocol type value
 */
#define CTTF_HRPD_MAX_VALID_PROTOCOL_TYPE                   ( 0x7FFF )

/*******************************************************************************
 3. Enumerations declarations
*******************************************************************************/

/** ****************************************************************************
 * Name        : CTTF_HRPD_ADDRESS_TYPE_ENUM_UINT8
 *
 * Description : From C.S0024-A v3.0:
 * 2.3.2 Addressing:
 * Addressing modes for the message. The sender of the message shall send the
 * message only with an address type(s)
 * indicated by this information field. Values are
 * -  Broadcast if a broadcast address can be used with this message,
 * -  Multicast if a multicast address can be used with this message, and
 * -  Unicast if a unicast address can be used with this message.
 *******************************************************************************/
enum CTTF_HRPD_ADDRESS_TYPE_ENUM
{
    CTTF_HRPD_ADDRESS_BROADCAST         = 0x00,
    CTTF_HRPD_ADDRESS_MULTICAST         = 0x01,
    CTTF_HRPD_ADDRESS_UNICAST           = 0x02,
    CTTF_HRPD_ADDRESS_TYPE_BUTT         = 0x03
};
typedef VOS_UINT8 CTTF_HRPD_ADDRESS_TYPE_ENUM_UINT8;

/** ****************************************************************************
 * Name        : CTTF_HRPD_BEST_EFFORT_NEED_RSLT_ENUM_UINT8
 *
 * Description :
 *******************************************************************************/
enum CTTF_HRPD_BEST_EFFORT_NEED_RSLT_ENUM
{
    CTTF_HRPD_BEST_EFFORT_NOT_NEED_RSLT = 0x00,
    CTTF_HRPD_BEST_EFFORT_NEED_RSLT     = 0x01,
    CTTF_HRPD_BEST_EFFORT_RSLT_BUTT     = 0xFF
};
typedef VOS_UINT8 CTTF_HRPD_BEST_EFFORT_NEED_RSLT_ENUM_UINT8;

/** ****************************************************************************
 * Name        : CTTF_HRPD_CHANNEL_TYPE_ENUM_UINT8
 *
 * Description : From C.S0024-A v3.0:
 * 2.3.2 Message Information:
 * Channels: This information field indicates the Physical Layer Channels on
 * which this message can be transmitted.
 * The sender of the message shall send the message only on the Physical Layer
 * channel(s) indicated by this information field.
 * Values are:
 * -  FTC for Forward Traffic Channel or Control Channel given that the Route
 * Update Protocol is in the Connected State,
 * -  CC for Control Channel (synchronous, sub-synchronous, or asynchronous
 * capsule),
 * -  CCsyn for Control Channel synchronous capsule (including the Control
 * Channel synchronous Sleep State capsule),
 * -  CCsubsyn for Control Channel sub-synchronous capsule (including the
 * Control Channel synchronous capsule)
 * -  CCsynSS for Control Channel Synchronous Sleep State capsule,
 * -  AC for Access Channel,
 * -  RTC for Reverse Traffic Channel,
 * -  BC for Broadcast Channel as defined in [14]
 * -  AC or RTC if don't make sure the channel is ac or rtc,use this type.
 *******************************************************************************/
enum CTTF_HRPD_CHANNEL_TYPE_ENUM
{
    CTTF_HRPD_CHANNEL_FTC               = 0x00,
    CTTF_HRPD_CHANNEL_CC                = 0x01,
    CTTF_HRPD_CHANNEL_CC_SYN            = 0x02,
    CTTF_HRPD_CHANNEL_CC_SUBSYN         = 0x03,
    CTTF_HRPD_CHANNEL_CC_SYN_SS         = 0x04,
    CTTF_HRPD_CHANNEL_AC                = 0x05,
    CTTF_HRPD_CHANNEL_RTC               = 0x06,
    CTTF_HRPD_CHANNEL_BC                = 0x07,
    CTTF_HRPD_CHANNEL_AC_OR_RTC         = 0x08,
    CTTF_HRPD_CHANNEL_BUTT              = 0x09
};
typedef VOS_UINT8 CTTF_HRPD_CHANNEL_TYPE_ENUM_UINT8;

/** ****************************************************************************
 * Name        : CTTF_HRPD_DELLIVERY_TYPE_ENUM_UINT8
 *
 * Description : From C.S0024-A v3.0:
 * The sender of the message shall send the  message only using the SLP in the
 * mode(s) indicated by this information field. Values are:
 * -  Best Effort: the message is sent once and is subject to erasure, and
 * -  Reliable: erasures are detected and the message is retransmitted one or
 * more times, if necessary.
 * -  If message could be sent on either AC or RTC channel, use AC_OR_RTC, and
 * meanwhile set type with Beat Effort. When the RTC channel is opened, it will
 * be replaced into Reliable then when sending message.
 *******************************************************************************/
enum CTTF_HRPD_DELLIVERY_TYPE_ENUM
{
    CTTF_HRPD_DELIVERY_TYPE_BEST_EFFORT = 0x00,
    CTTF_HRPD_DELIVERY_TYPE_RELIABLE    = 0x01,
    CTTF_HRPD_DELIVERY_TYPE_BUTT        = 0x02
};
typedef VOS_UINT8 CTTF_HRPD_DELLIVERY_TYPE_ENUM_UINT8;

/** ****************************************************************************
 * Name        : CTTF_HRPD_INSTANCE_TYPE_ENUM_UINT8
 *
 * Description : From C.S0024-A v3.0:
 * 1.6.3 InUse and InConfiguration Protocol/Application Instances
 * A protocol/application instance can be either an InUse instance or an
 * InConfiguration instance.
 *******************************************************************************/
enum CTTF_HRPD_INSTANCE_TYPE_ENUM
{
    CTTF_HRPD_INSTANCE_INUSE            = 0x00,
    CTTF_HRPD_INSTANCE_INCONFIGURATION  = 0x01,
    CTTF_HRPD_INSTANCE_BUTT             = 0x02
};
typedef VOS_UINT8 CTTF_HRPD_INSTANCE_TYPE_ENUM_UINT8;

/** ****************************************************************************
 * Name        : CTTF_HRPD_PROTOCOL_TYPE_ENUM_UINT16
 *
 * Description : From C.S0024-A v3.0:
 * Table 2.5.4-1. Default Protocol Stack Type Values
 *******************************************************************************/
enum CTTF_HRPD_PROTOCOL_TYPE_ENUM
{
    CTTF_HRPD_SNP_PHYSICAL_LAYER_PROTOCOL                   = 0x0000,
    CTTF_HRPD_SNP_CONTROL_CHANNEL_MAC_PROTOCOL              = 0x0001,
    CTTF_HRPD_SNP_ACCESS_CHANNEL_MAC_PROTOCOL               = 0x0002,
    CTTF_HRPD_SNP_FORWARD_TRAFFIC_CHANNEL_MAC_PROTOCOL      = 0x0003,
    CTTF_HRPD_SNP_REVERSE_TRAFFIC_CHANNEL_MAC_PROTOCOL      = 0x0004,
    CTTF_HRPD_SNP_KEY_EXCHANGE_PROTOCOL                     = 0x0005,
    CTTF_HRPD_SNP_AUTHENTICATION_PROTOCOL                   = 0x0006,
    CTTF_HRPD_SNP_ENCRYPTION_PROTOCOL                       = 0x0007,
    CTTF_HRPD_SNP_SECURITY_PROTOCOL                         = 0x0008,
    CTTF_HRPD_SNP_PACKET_CONSOLIDATION_PROTOCOL             = 0x0009,
    CTTF_HRPD_SNP_AIR_LINK_MANAGEMENT_PROTOCOL              = 0x000A,
    CTTF_HRPD_SNP_INITIALIZATION_STATE_PROTOCOL             = 0x000B,
    CTTF_HRPD_SNP_IDLE_STATE_PROTOCOL                       = 0x000C,
    CTTF_HRPD_SNP_CONNECTED_STATE_PROTOCOL                  = 0x000D,
    CTTF_HRPD_SNP_ROUTE_UPDATE_PROTOCOL                     = 0x000E,
    CTTF_HRPD_SNP_OVERHEAD_MESSAGES_PROTOCOL                = 0x000F,
    CTTF_HRPD_SNP_SESSION_MANAGEMENT_PROTOCOL               = 0x0010,
    CTTF_HRPD_SNP_ADDRESS_MANAGEMENT_PROTOCOL               = 0x0011,
    CTTF_HRPD_SNP_SESSION_CONFIGURATION_PROTOCOL            = 0x0012,
    CTTF_HRPD_SNP_STREAM_PROTOCOL                           = 0x0013,
    CTTF_HRPD_SNP_STREAM_0_APPLICATION_PROTOCOL             = 0x0014,
    CTTF_HRPD_SNP_STREAM_1_APPLICATION_PROTOCOL             = 0x0015,
    CTTF_HRPD_SNP_STREAM_2_APPLICATION_PROTOCOL             = 0x0016,
    CTTF_HRPD_SNP_STREAM_3_APPLICATION_PROTOCOL             = 0x0017,
    CTTF_HRPD_SNP_BCMCS_PROTOCOL                            = 0x0018,
    CTTF_HRPD_SNP_VIRTUAL_STREAM_PROTOCOL                   = 0x0019,
    CTTF_HRPD_SNP_MM_CAPABILITY_DISCOVERY_PROTOCOL          = 0x001B,
    CTTF_HRPD_SNP_INTERRAT_SIGNALING_ADAPTATION_PROTOCOL    = 0x001D,
    CTTF_HRPD_SNP_PROTOCOL_TYPE_BUTT                        = 0x001E
};
typedef VOS_UINT16 CTTF_HRPD_PROTOCOL_TYPE_ENUM_UINT16;

/** ****************************************************************************
 * Name        : CTTF_HRPD_SNP_DATA_FAIL_REASON_ENUM_UINT32
 *
 * Description : It's used to indicate which reason caused signal data
 * transmission failure.
 *******************************************************************************/
enum CTTF_HRPD_SNP_DATA_FAIL_REASON_ENUM
{
    CTTF_HRPD_SNP_DATA_FAIL_REASON_GENERIC_ERROR            = 0x00000000,
    CTTF_HRPD_SNP_DATA_FAIL_REASON_AC_CHANNEL_NOT_EXIST     = 0x00000001, /**< access channel not exist */
    CTTF_HRPD_SNP_DATA_FAIL_REASON_SLP_RESET                = 0x00000002, /**< SLP met reset operation */
    CTTF_HRPD_SNP_DATA_FAIL_REASON_CAN_NOT_TX               = 0x00000003, /**< received indication from CAS that not allow to do transmission */
    CTTF_HRPD_SNP_DATA_FAIL_REASON_CONN_CLOSE               = 0x00000004, /**< received ConnectionClosed indication */
    CTTF_HRPD_SNP_DATA_FAIL_REASON_RELEASE_ALL              = 0x00000005, /**< received release-all message */
    CTTF_HRPD_SNP_DATA_FAIL_REASON_ENUM_BUTT                = 0x00000006
};
typedef VOS_UINT32 CTTF_HRPD_SNP_DATA_FAIL_REASON_ENUM_UINT32;

/** ****************************************************************************
 * Name        : CTTF_HRPD_SNP_RSLT_ENUM_UINT32
 *
 * Description : This is an ENUM for operation result between CAS/CNAS and SNP
 * in HRPD.
 *******************************************************************************/
enum CTTF_HRPD_SNP_RSLT_ENUM
{
    CTTF_HRPD_SNP_RLST_SUCC             = 0x00000000,
    CTTF_HRPD_SNP_RSLT_FAIL             = 0x00000001,
    CTTF_HRPD_SNP_RSLT_ENUM_BUTT        = 0x00000002
};
typedef VOS_UINT32 CTTF_HRPD_SNP_RSLT_ENUM_UINT32;

/*******************************************************************************
 4. Message Header declaration
*******************************************************************************/

/*******************************************************************************
 5. Message declaration
*******************************************************************************/

/*******************************************************************************
 6. STRUCT and UNION declaration
*******************************************************************************/

/** ****************************************************************************
 * Name        : SNPITF_MSG_DATA_STRU
 *
 * Description : Message delivered to/from other protocols. Messages are always
 * an integer number of octets in length; and, if necessary, include a
 * Reserved field at the end of the message to make them so. The receiver shall
 * ignore the value of the Reserved fields.
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          usMsgBitLen;   /**< message length(bits) */
    VOS_UINT8                           aucReserve[2];
    VOS_UINT8                           aucMsgData[4]; /**< first four octets of message data */
} SNPITF_MSG_DATA_STRU;

/** ****************************************************************************
 * Name        : SNPITF_MSG_TTF_MEM_STRU
 *
 * Description : Message delivered to/from other protocols. Messages are always
 * an integer number of octets in length; and, if necessary, include a Reserved
 * field at the end of the message to make them so. The receiver shall ignore
 * the value of the Reserved fields.
 *******************************************************************************/
typedef struct
{
    VOS_UINT16                          usMsgByteLen;  /**< message length(bytes) */
    VOS_UINT8                           aucReserve[1];
    PS_BOOL_ENUM_UINT8                  enMemFreeInd; /**< indicates if the TTF_MEM can be freed or not by SIG, PS_TRUE: shall be freed by SIG, PS_FALSE: shall not be freed by SIG */
    TTF_MEM_ST                         *pstMsgData;   /**< pointer of message ttf memory data */
} SNPITF_MSG_TTF_MEM_STRU;

/*******************************************************************************
 7. OTHER declarations
*******************************************************************************/

/*******************************************************************************
 8. Global  declaration
*******************************************************************************/

/*******************************************************************************
 9. Function declarations
*******************************************************************************/

#if ((VOS_OS_VER == VOS_WIN32) || (VOS_OS_VER == VOS_NUCLEUS))
#pragma pack()
#else
#pragma pack(0)
#endif

#ifdef __cplusplus
#if __cplusplus
}
#endif /* __cpluscplus */
#endif /* __cpluscplus */

#endif
